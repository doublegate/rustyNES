Project Path: rustyNES

Source Tree:

```
rustyNES
├── Cargo.toml
├── LICENSE
├── README.md
├── SDL2.dll
├── SDL2.lib
├── SDL2main.lib
└── src
    ├── apu.rs
    ├── audio
    │   ├── dsp.rs
    │   ├── mod.rs
    │   └── output.rs
    ├── cartridge.rs
    ├── controller.rs
    ├── cpu.rs
    ├── main.rs
    ├── mappers
    │   ├── mapper000.rs
    │   ├── mapper001.rs
    │   ├── mapper002.rs
    │   ├── mapper003.rs
    │   ├── mapper004.rs
    │   └── mod.rs
    ├── memory.rs
    ├── nes.rs
    ├── ppu
    │   ├── background.rs
    │   ├── mod.rs
    │   ├── palette.rs
    │   └── sprites.rs
    ├── savestate.rs
    └── util.rs

```

`\\?\C:\Users\parobek\GitHub\rustyNES\Cargo.toml`:

```toml
[package]
name = "rusty_nes"
version = "0.1.0"
edition = "2021"
authors = ["DoubleGate <parobek@gmail.com>"]
description = "rustyNES - Nintendo Entertainment System (NES) Emulator (Rust Language)"
repository = "https://github.com/doublegate/rustyNES"
license = "MIT"
readme = "README.md"

[dependencies]
log = "0.4"
env_logger = "0.11.7"
clap = { version = "4.3", features = ["derive"] }
sdl2 = { version = "0.37.0", features = ["bundled"] }
anyhow = "1.0"
thiserror = "2.0.12"
windows = { version = "0.61.1", features = ["Win32_Graphics_Direct2D", "Win32_Graphics_Direct2D_Common", "Win32_Foundation", "Win32_UI_WindowsAndMessaging"] }
bincode = "2.0.1"
serde = { version = "1.0.219", features = ["derive"] }
image = "0.25.5"

[profile.release]
lto = true
codegen-units = 1
panic = "abort"
opt-level = 3
debug = false

```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\apu.rs`:

```rs
//! APU (Audio Processing Unit) implementation
//!
//! The APU handles audio generation for the NES. It includes multiple sound channels:
//! - 2 pulse wave channels
//! - 1 triangle wave channel
//! - 1 noise channel
//! - 1 DMC (Delta Modulation Channel)
//!
//! This implementation provides cycle-accurate timing for proper audio playback.

// use log::{debug, trace};

use crate::memory::MemoryBus;

/// Sample rate for audio output (Hz)
const SAMPLE_RATE: u32 = 44100;

/// CPU clock rate (Hz) - NTSC
const CPU_CLOCK_RATE: f64 = 1789773.0;

/// Represents the NES APU (Audio Processing Unit)
pub struct APU {
    /// Pulse 1 channel registers
    pulse1: PulseChannel,
    
    /// Pulse 2 channel registers
    pulse2: PulseChannel,
    
    /// Triangle channel registers
    triangle: TriangleChannel,
    
    /// Noise channel registers
    noise: NoiseChannel,
    
    /// DMC channel registers
    dmc: DMCChannel,
    
    /// Frame counter register
    frame_counter: u8,
    
    /// Frame IRQ inhibit flag
    frame_irq_inhibit: bool,
    
    /// Frame counter mode (0 = 4-step, 1 = 5-step)
    frame_counter_mode: bool,
    
    /// Frame sequence step
    frame_sequence: u8,
    
    /// Cycle counter
    cycles: u64,
    
    /// Sample counter
    sample_counter: f64,
    
    /// Audio samples buffer
    samples: Vec<f32>,
}

/// Pulse (square wave) channel
struct PulseChannel {
    /// Channel enabled
    enabled: bool,
    
    /// Duty cycle (0-3)
    duty: u8,
    
    /// Length counter halt / envelope loop flag
    length_counter_halt: bool,
    
    /// Constant volume / envelope flag
    constant_volume: bool,
    
    /// Volume / envelope period
    volume: u8,
    
    /// Sweep enabled flag
    sweep_enabled: bool,
    
    /// Sweep period
    sweep_period: u8,
    
    /// Sweep negative flag
    sweep_negative: bool,
    
    /// Sweep shift count
    sweep_shift: u8,
    
    /// Timer period
    timer_period: u16,
    
    /// Length counter value
    length_counter: u8,
    
    /// Current timer value
    timer: u16,
    
    /// Current sequencer step
    sequencer_step: u8,
    
    /// Envelope start flag
    envelope_start: bool,
    
    /// Envelope divider
    envelope_divider: u8,
    
    /// Envelope decay counter
    envelope_decay: u8,
    
    /// Envelope volume
    envelope_volume: u8,
    
    /// Sweep reload flag
    sweep_reload: bool,
    
    /// Sweep divider
    sweep_divider: u8,
    
    /// Muted flag (for sweep calculations)
    muted: bool,
}

/// Triangle wave channel
struct TriangleChannel {
    /// Channel enabled
    enabled: bool,
    
    /// Linear counter reload flag
    linear_counter_reload: bool,
    
    /// Linear counter reload value
    linear_counter_period: u8,
    
    /// Length counter halt / linear counter control flag
    length_counter_halt: bool,
    
    /// Timer period
    timer_period: u16,
    
    /// Length counter value
    length_counter: u8,
    
    /// Current timer value
    timer: u16,
    
    /// Current sequencer step
    sequencer_step: u8,
    
    /// Linear counter value
    linear_counter: u8,
    
    /// Linear counter reload flag
    linear_counter_reload_flag: bool,
}

/// Noise channel
struct NoiseChannel {
    /// Channel enabled
    enabled: bool,
    
    /// Length counter halt / envelope loop flag
    length_counter_halt: bool,
    
    /// Constant volume / envelope flag
    constant_volume: bool,
    
    /// Volume / envelope period
    volume: u8,
    
    /// Mode flag
    mode: bool,
    
    /// Timer period
    timer_period: u16,
    
    /// Length counter value
    length_counter: u8,
    
    /// Current timer value
    timer: u16,
    
    /// Shift register
    shift_register: u16,
    
    /// Envelope start flag
    envelope_start: bool,
    
    /// Envelope divider
    envelope_divider: u8,
    
    /// Envelope decay counter
    envelope_decay: u8,
    
    /// Envelope volume
    envelope_volume: u8,
}

/// DMC (Delta Modulation Channel)
struct DMCChannel {
    /// Channel enabled
    enabled: bool,
    
    /// IRQ enabled
    irq_enabled: bool,
    
    /// Loop flag
    loop_flag: bool,
    
    /// Timer period
    timer_period: u16,
    
    /// Output level
    output_level: u8,
    
    /// Sample address
    sample_address: u16,
    
    /// Sample length
    sample_length: u16,
    
    /// Current timer value
    timer: u16,
    
    /// Current sample buffer
    sample_buffer: u8,
    
    /// Sample buffer empty flag
    sample_buffer_empty: bool,
    
    /// Current address
    current_address: u16,
    
    /// Bytes remaining
    bytes_remaining: u16,
    
    /// Shift register
    shift_register: u8,
    
    /// Bits remaining
    bits_remaining: u8,
    
    /// Silent flag
    silent: bool,
}

/// Initialize default values for a pulse channel
impl Default for PulseChannel {
    fn default() -> Self {
        PulseChannel {
            enabled: false,
            duty: 0,
            length_counter_halt: false,
            constant_volume: false,
            volume: 0,
            sweep_enabled: false,
            sweep_period: 0,
            sweep_negative: false,
            sweep_shift: 0,
            timer_period: 0,
            length_counter: 0,
            timer: 0,
            sequencer_step: 0,
            envelope_start: false,
            envelope_divider: 0,
            envelope_decay: 0,
            envelope_volume: 0,
            sweep_reload: false,
            sweep_divider: 0,
            muted: false,
        }
    }
}

/// Initialize default values for a triangle channel
impl Default for TriangleChannel {
    fn default() -> Self {
        TriangleChannel {
            enabled: false,
            linear_counter_reload: false,
            linear_counter_period: 0,
            length_counter_halt: false,
            timer_period: 0,
            length_counter: 0,
            timer: 0,
            sequencer_step: 0,
            linear_counter: 0,
            linear_counter_reload_flag: false,
        }
    }
}

/// Initialize default values for a noise channel
impl Default for NoiseChannel {
    fn default() -> Self {
        NoiseChannel {
            enabled: false,
            length_counter_halt: false,
            constant_volume: false,
            volume: 0,
            mode: false,
            timer_period: 0,
            length_counter: 0,
            timer: 0,
            shift_register: 1,  // Initialize to 1
            envelope_start: false,
            envelope_divider: 0,
            envelope_decay: 0,
            envelope_volume: 0,
        }
    }
}

/// Initialize default values for a DMC channel
impl Default for DMCChannel {
    fn default() -> Self {
        DMCChannel {
            enabled: false,
            irq_enabled: false,
            loop_flag: false,
            timer_period: 0,
            output_level: 0,
            sample_address: 0,
            sample_length: 0,
            timer: 0,
            sample_buffer: 0,
            sample_buffer_empty: true,
            current_address: 0,
            bytes_remaining: 0,
            shift_register: 0,
            bits_remaining: 0,
            silent: true,
        }
    }
}

impl APU {
    /// Create a new APU instance
    pub fn new() -> Self {
        APU {
            pulse1: PulseChannel::default(),
            pulse2: PulseChannel::default(),
            triangle: TriangleChannel::default(),
            noise: NoiseChannel::default(),
            dmc: DMCChannel::default(),
            frame_counter: 0,
            frame_irq_inhibit: false,
            frame_counter_mode: false,
            frame_sequence: 0,
            cycles: 0,
            sample_counter: 0.0,
            samples: Vec::new(),
        }
    }

    /// Reset the APU
    pub fn reset(&mut self) {
        self.pulse1 = PulseChannel::default();
        self.pulse2 = PulseChannel::default();
        self.triangle = TriangleChannel::default();
        self.noise = NoiseChannel::default();
        self.dmc = DMCChannel::default();
        self.frame_counter = 0;
        self.frame_irq_inhibit = false;
        self.frame_counter_mode = false;
        self.frame_sequence = 0;
        self.cycles = 0;
        self.sample_counter = 0.0;
        self.samples.clear();
    }

    /// Run a single APU cycle
    pub fn step(&mut self, bus: &mut MemoryBus) {
        // Process frame counter
        if self.cycles % 2 == 0 {
            self.step_frame_counter();
        }
        
        // Process pulse channels
        if self.cycles % 2 == 0 {
            let pulse1 = &mut self.pulse1;
            let pulse2 = &mut self.pulse2;
            pulse1.timer = if pulse1.timer > 0 { pulse1.timer - 1 } else {
                let new_timer = pulse1.timer_period;
                pulse1.sequencer_step = (pulse1.sequencer_step + 1) % 8;
                new_timer
            };
            pulse2.timer = if pulse2.timer > 0 { pulse2.timer - 1 } else {
                let new_timer = pulse2.timer_period;
                pulse2.sequencer_step = (pulse2.sequencer_step + 1) % 8;
                new_timer
            };
        }
        
        // Process triangle channel
        self.step_triangle_timer();
        
        // Process noise channel
        if self.cycles % 2 == 0 {
            self.step_noise_timer();
        }
        
        // Process DMC channel
        if self.cycles % 2 == 0 {
            self.step_dmc_timer(bus);
        }
        
        // Generate audio sample
        self.sample_counter += 1.0;
        let samples_per_clock = SAMPLE_RATE as f64 / CPU_CLOCK_RATE;
        
        if self.sample_counter >= 1.0 / samples_per_clock {
            self.sample_counter -= 1.0 / samples_per_clock;
            self.generate_sample();
        }
        
        self.cycles += 1;
    }

    /// Process frame counter
    fn step_frame_counter(&mut self) {
        // 4-step sequence:
        // 0: 1/4 frame - Envelope and triangle linear counter
        // 1: 1/2 frame - Envelope, triangle linear counter, length counter, and sweep
        // 2: 3/4 frame - Envelope and triangle linear counter
        // 3: Frame complete - Envelope, triangle linear counter, length counter, sweep, and (optionally) IRQ
        
        // 5-step sequence:
        // 0: 1/5 frame - Envelope and triangle linear counter
        // 1: 2/5 frame - Envelope, triangle linear counter, length counter, and sweep
        // 2: 3/5 frame - Envelope and triangle linear counter
        // 3: 4/5 frame - Envelope, triangle linear counter, length counter, and sweep
        // 4: Frame complete - Nothing (no IRQ)
        
        let steps = if self.frame_counter_mode { 5 } else { 4 };
        
        if (self.cycles % 7457) == 0 {
            self.frame_sequence = (self.frame_sequence + 1) % steps;
            
            // Clock envelopes and triangle linear counter
            if self.frame_sequence % 2 == 0 {
                self.clock_envelopes();
                self.clock_triangle_linear_counter();
            }
            
            // Clock length counters and sweep units
            if self.frame_sequence == 1 || self.frame_sequence == 3 {
                self.clock_length_counters();
                self.clock_sweep_units();
            }
            
            // Generate IRQ for 4-step sequence
            if !self.frame_counter_mode && self.frame_sequence == 3 && !self.frame_irq_inhibit {
                // In a complete implementation, this would trigger an IRQ
            }
        }
    }

    /// Clock channel envelopes
    fn clock_envelopes(&mut self) {
        // Pulse 1 envelope
        if self.pulse1.envelope_start {
            self.pulse1.envelope_start = false;
            self.pulse1.envelope_divider = self.pulse1.volume;
            self.pulse1.envelope_decay = 15;
        } else if self.pulse1.envelope_divider > 0 {
            self.pulse1.envelope_divider -= 1;
        } else {
            self.pulse1.envelope_divider = self.pulse1.volume;
            
            if self.pulse1.envelope_decay > 0 {
                self.pulse1.envelope_decay -= 1;
            } else if self.pulse1.length_counter_halt {
                self.pulse1.envelope_decay = 15;
            }
        }
        
        // Pulse 2 envelope
        if self.pulse2.envelope_start {
            self.pulse2.envelope_start = false;
            self.pulse2.envelope_divider = self.pulse2.volume;
            self.pulse2.envelope_decay = 15;
        } else if self.pulse2.envelope_divider > 0 {
            self.pulse2.envelope_divider -= 1;
        } else {
            self.pulse2.envelope_divider = self.pulse2.volume;
            
            if self.pulse2.envelope_decay > 0 {
                self.pulse2.envelope_decay -= 1;
            } else if self.pulse2.length_counter_halt {
                self.pulse2.envelope_decay = 15;
            }
        }
        
        // Noise envelope
        if self.noise.envelope_start {
            self.noise.envelope_start = false;
            self.noise.envelope_divider = self.noise.volume;
            self.noise.envelope_decay = 15;
        } else if self.noise.envelope_divider > 0 {
            self.noise.envelope_divider -= 1;
        } else {
            self.noise.envelope_divider = self.noise.volume;
            
            if self.noise.envelope_decay > 0 {
                self.noise.envelope_decay -= 1;
            } else if self.noise.length_counter_halt {
                self.noise.envelope_decay = 15;
            }
        }
    }

    /// Clock triangle linear counter
    fn clock_triangle_linear_counter(&mut self) {
        if self.triangle.linear_counter_reload_flag {
            self.triangle.linear_counter = self.triangle.linear_counter_period;
        } else if self.triangle.linear_counter > 0 {
            self.triangle.linear_counter -= 1;
        }
        
        if !self.triangle.length_counter_halt {
            self.triangle.linear_counter_reload_flag = false;
        }
    }

    /// Clock length counters
    fn clock_length_counters(&mut self) {
        if self.pulse1.length_counter > 0 && !self.pulse1.length_counter_halt {
            self.pulse1.length_counter -= 1;
        }
        
        if self.pulse2.length_counter > 0 && !self.pulse2.length_counter_halt {
            self.pulse2.length_counter -= 1;
        }
        
        if self.triangle.length_counter > 0 && !self.triangle.length_counter_halt {
            self.triangle.length_counter -= 1;
        }
        
        if self.noise.length_counter > 0 && !self.noise.length_counter_halt {
            self.noise.length_counter -= 1;
        }
    }

    /// Clock sweep units
    fn clock_sweep_units(&mut self) {
        // Pulse 1 sweep
        if self.pulse1.sweep_divider == 0 && self.pulse1.sweep_enabled && self.pulse1.sweep_shift > 0 && !self.pulse1.muted {
            let delta = self.pulse1.timer_period >> self.pulse1.sweep_shift;
            
            if self.pulse1.sweep_negative {
                self.pulse1.timer_period -= delta;
            } else {
                self.pulse1.timer_period += delta;
            }
            
            // Check for muting
            if self.pulse1.timer_period > 0x7FF || self.pulse1.timer_period < 8 {
                self.pulse1.muted = true;
            }
        }
        
        if self.pulse1.sweep_reload {
            self.pulse1.sweep_divider = self.pulse1.sweep_period;
            self.pulse1.sweep_reload = false;
        } else if self.pulse1.sweep_divider > 0 {
            self.pulse1.sweep_divider -= 1;
        } else {
            self.pulse1.sweep_divider = self.pulse1.sweep_period;
        }
        
        // Pulse 2 sweep
        if self.pulse2.sweep_divider == 0 && self.pulse2.sweep_enabled && self.pulse2.sweep_shift > 0 && !self.pulse2.muted {
            let delta = self.pulse2.timer_period >> self.pulse2.sweep_shift;
            
            if self.pulse2.sweep_negative {
                self.pulse2.timer_period -= delta;
            } else {
                self.pulse2.timer_period += delta;
            }
            
            // Check for muting
            if self.pulse2.timer_period > 0x7FF || self.pulse2.timer_period < 8 {
                self.pulse2.muted = true;
            }
        }
        
        if self.pulse2.sweep_reload {
            self.pulse2.sweep_divider = self.pulse2.sweep_period;
            self.pulse2.sweep_reload = false;
        } else if self.pulse2.sweep_divider > 0 {
            self.pulse2.sweep_divider -= 1;
        } else {
            self.pulse2.sweep_divider = self.pulse2.sweep_period;
        }
    }

    /// Step triangle timer
    fn step_triangle_timer(&mut self) {
        if self.triangle.timer > 0 {
            self.triangle.timer -= 1;
        } else {
            self.triangle.timer = self.triangle.timer_period;
            
            if self.triangle.linear_counter > 0 && self.triangle.length_counter > 0 {
                self.triangle.sequencer_step = (self.triangle.sequencer_step + 1) % 32;
            }
        }
    }

    /// Step noise timer
    fn step_noise_timer(&mut self) {
        if self.noise.timer > 0 {
            self.noise.timer -= 1;
        } else {
            self.noise.timer = self.noise.timer_period;
            
            // Shift the noise LFSR
            let feedback = (self.noise.shift_register & 1) ^ ((self.noise.shift_register >> (if self.noise.mode { 6 } else { 1 })) & 1);
            self.noise.shift_register = (self.noise.shift_register >> 1) | (feedback << 14);
        }
    }

    /// Step DMC timer
    fn step_dmc_timer(&mut self, _bus: &mut MemoryBus) {
        // DMC playback handling
        // In a complete implementation, this would handle DMC sample loading and playback
        if self.dmc.timer > 0 {
            self.dmc.timer -= 1;
        } else {
            self.dmc.timer = self.dmc.timer_period;
            
            if !self.dmc.silent {
                // Output bit and update level
                let bit = self.dmc.shift_register & 1;
                self.dmc.shift_register >>= 1;
                
                if bit != 0 {
                    if self.dmc.output_level <= 125 {
                        self.dmc.output_level += 2;
                    }
                } else {
                    if self.dmc.output_level >= 2 {
                        self.dmc.output_level -= 2;
                    }
                }
            }
            
            self.dmc.bits_remaining -= 1;
            if self.dmc.bits_remaining == 0 {
                self.dmc.bits_remaining = 8;
                
                if self.dmc.sample_buffer_empty {
                    self.dmc.silent = true;
                } else {
                    self.dmc.silent = false;
                    self.dmc.shift_register = self.dmc.sample_buffer;
                    self.dmc.sample_buffer_empty = true;
                    
                    // Fetch next sample
                    if self.dmc.bytes_remaining > 0 {
                        // In a complete implementation, this would handle DMC sample loading
                    }
                }
            }
        }
    }

    /// Generate an audio sample
    fn generate_sample(&mut self) {
        // Get pulse channel outputs
        let pulse1_output = if self.pulse1.length_counter > 0 && !self.pulse1.muted {
            // Pulse waveform lookup based on duty cycle
            let pulse_table: [u8; 4] = [0b00000001, 0b00000011, 0b00001111, 0b11111100];
            let waveform = (pulse_table[self.pulse1.duty as usize] >> self.pulse1.sequencer_step) & 1;
            
            if waveform != 0 {
                if self.pulse1.constant_volume {
                    self.pulse1.volume
                } else {
                    self.pulse1.envelope_decay
                }
            } else {
                0
            }
        } else {
            0
        } as f32;
        
        let pulse2_output = if self.pulse2.length_counter > 0 && !self.pulse2.muted {
            // Pulse waveform lookup based on duty cycle
            let pulse_table: [u8; 4] = [0b00000001, 0b00000011, 0b00001111, 0b11111100];
            let waveform = (pulse_table[self.pulse2.duty as usize] >> self.pulse2.sequencer_step) & 1;
            
            if waveform != 0 {
                if self.pulse2.constant_volume {
                    self.pulse2.volume
                } else {
                    self.pulse2.envelope_decay
                }
            } else {
                0
            }
        } else {
            0
        } as f32;
        
        // Get triangle channel output
        let triangle_output = if self.triangle.length_counter > 0 && self.triangle.linear_counter > 0 {
            // Triangle waveform is a sequence of 32 steps
            static TRIANGLE_TABLE: [u8; 32] = [
                15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
            ];
            
            TRIANGLE_TABLE[self.triangle.sequencer_step as usize]
        } else {
            0
        } as f32;
        
        // Get noise channel output
        let noise_output = if self.noise.length_counter > 0 && (self.noise.shift_register & 1) == 0 {
            if self.noise.constant_volume {
                self.noise.volume
            } else {
                self.noise.envelope_decay
            }
        } else {
            0
        } as f32;
        
        // Get DMC output
        let dmc_output = self.dmc.output_level as f32;
        
        // Mix all channels
        // These values are approximations of the NES's audio mixing circuit
        let pulse_out = 0.00752 * (pulse1_output + pulse2_output);
        let tnd_out = 0.00851 * triangle_output + 0.00494 * noise_output + 0.00335 * dmc_output;
        
        // Final output is in the range [-1.0, 1.0]
        let sample = pulse_out + tnd_out;
        self.samples.push(sample);
    }

    /// Get the current audio samples
    pub fn get_samples(&mut self) -> Vec<f32> {
        let samples = self.samples.clone();
        self.samples.clear();
        samples
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\audio\dsp.rs`:

```rs
//! Digital Signal Processing for audio
//!
//! This module provides DSP filters for audio processing.

/// Low-pass filter (attenuate high frequencies)
pub struct LowPassFilter {
    /// Sample rate
    sample_rate: f32,
    
    /// Cutoff frequency
    cutoff: f32,
    
    /// Filter coefficient
    alpha: f32,
    
    /// Previous output
    prev_output: f32,
}

/// High-pass filter (attenuate low frequencies)
pub struct HighPassFilter {
    /// Sample rate
    sample_rate: f32,
    
    /// Cutoff frequency
    cutoff: f32,
    
    /// Filter coefficient
    alpha: f32,
    
    /// Previous input
    prev_input: f32,
    
    /// Previous output
    prev_output: f32,
}

impl LowPassFilter {
    /// Create a new low-pass filter
    pub fn new(sample_rate: u32, cutoff: f32) -> Self {
        let sample_rate = sample_rate as f32;
        let dt = 1.0 / sample_rate;
        let rc = 1.0 / (2.0 * std::f32::consts::PI * cutoff);
        let alpha = dt / (dt + rc);
        
        LowPassFilter {
            sample_rate,
            cutoff,
            alpha,
            prev_output: 0.0,
        }
    }
    
    /// Process a sample through the filter
    pub fn process(&mut self, input: f32) -> f32 {
        self.prev_output = self.prev_output + self.alpha * (input - self.prev_output);
        self.prev_output
    }
    
    /// Set the cutoff frequency
    pub fn set_cutoff(&mut self, cutoff: f32) {
        self.cutoff = cutoff;
        let dt = 1.0 / self.sample_rate;
        let rc = 1.0 / (2.0 * std::f32::consts::PI * cutoff);
        self.alpha = dt / (dt + rc);
    }
}

impl HighPassFilter {
    /// Create a new high-pass filter
    pub fn new(sample_rate: u32, cutoff: f32) -> Self {
        let sample_rate = sample_rate as f32;
        let dt = 1.0 / sample_rate;
        let rc = 1.0 / (2.0 * std::f32::consts::PI * cutoff);
        let alpha = rc / (dt + rc);
        
        HighPassFilter {
            sample_rate,
            cutoff,
            alpha,
            prev_input: 0.0,
            prev_output: 0.0,
        }
    }
    
    /// Process a sample through the filter
    pub fn process(&mut self, input: f32) -> f32 {
        self.prev_output = self.alpha * (self.prev_output + input - self.prev_input);
        self.prev_input = input;
        self.prev_output
    }
    
    /// Set the cutoff frequency
    pub fn set_cutoff(&mut self, cutoff: f32) {
        self.cutoff = cutoff;
        let dt = 1.0 / self.sample_rate;
        let rc = 1.0 / (2.0 * std::f32::consts::PI * cutoff);
        self.alpha = rc / (dt + rc);
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\audio\mod.rs`:

```rs
//! Audio processing and output
//!
//! This module handles audio filtering, mixing, and output for the NES emulator.

mod dsp;
mod output;

pub use dsp::*;
pub use output::*;

use crate::apu::APU;

/// Audio sample format (16-bit signed PCM)
pub type Sample = i16;

/// Audio buffer (stereo interleaved samples)
pub type AudioBuffer = Vec<Sample>;

/// Audio system for processing and outputting sound
pub struct AudioSystem {
    /// Sample rate
    sample_rate: u32,
    
    /// Low-pass filter
    low_pass: LowPassFilter,
    
    /// High-pass filter
    high_pass: HighPassFilter,
    
    /// Audio output
    output: AudioOutput,
    
    /// Temporary buffer for processing
    buffer: AudioBuffer,
    
    /// Volume (0.0 - 1.0)
    volume: f32,
}

impl AudioSystem {
    /// Create a new audio system
    pub fn new(sample_rate: u32) -> Self {
        AudioSystem {
            sample_rate,
            low_pass: LowPassFilter::new(sample_rate, 12000.0),
            high_pass: HighPassFilter::new(sample_rate, 40.0),
            output: AudioOutput::new(sample_rate),
            buffer: Vec::new(),
            volume: 0.75,
        }
    }
    
    /// Process audio samples from the APU
    pub fn process(&mut self, apu: &mut APU) {
        // Get raw samples from APU
        let raw_samples = apu.get_samples();
        
        // Prepare buffer
        self.buffer.clear();
        self.buffer.reserve(raw_samples.len() * 2); // Stereo
        
        // Process samples
        for sample in raw_samples {
            // Apply volume
            let amplified = sample * self.volume;
            
            // Apply filters
            let filtered = self.high_pass.process(self.low_pass.process(amplified));
            
            // Convert to 16-bit PCM and duplicate for stereo
            let pcm = (filtered * 32767.0) as i16;
            self.buffer.push(pcm);  // Left
            self.buffer.push(pcm);  // Right
        }
        
        // Output audio
        self.output.queue_audio(&self.buffer);
    }
    
    /// Set volume (0.0 - 1.0)
    pub fn set_volume(&mut self, volume: f32) {
        self.volume = volume.max(0.0).min(1.0);
    }
    
    /// Get current volume
    pub fn volume(&self) -> f32 {
        self.volume
    }
    
    /// Pause audio output
    pub fn pause(&mut self) {
        self.output.pause();
    }
    
    /// Resume audio output
    pub fn resume(&mut self) {
        self.output.resume();
    }
    
    /// Close audio output
    pub fn close(&mut self) {
        self.output.close();
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\audio\output.rs`:

```rs
//! Audio output implementation
//!
//! This module handles outputting audio to the sound device.

use log::{debug, error, warn};
use sdl2::audio::{AudioCallback, AudioDevice, AudioSpecDesired};
use std::sync::mpsc::{channel, Receiver, Sender};
use std::collections::VecDeque;

use super::Sample;

/// Audio callback for SDL2
struct NesAudioCallback {
    /// Audio buffer
    buffer: VecDeque<Sample>,
    
    /// Channel for receiving audio data
    receiver: Receiver<Vec<Sample>>,
}

impl AudioCallback for NesAudioCallback {
    type Channel = Sample;
    
    fn callback(&mut self, out: &mut [Self::Channel]) {
        // Check for new audio data
        while let Ok(samples) = self.receiver.try_recv() {
            for sample in samples {
                self.buffer.push_back(sample);
            }
        }
        
        // Fill output buffer
        for dst in out.iter_mut() {
            *dst = match self.buffer.pop_front() {
                Some(sample) => sample,
                None => 0,
            };
        }
    }
}

/// Audio output system
pub struct AudioOutput {
    /// SDL2 audio device
    device: Option<AudioDevice<NesAudioCallback>>,
    
    /// Sender for audio data
    sender: Sender<Vec<Sample>>,
    
    /// Sample rate
    sample_rate: u32,
}

impl AudioOutput {
    /// Create a new audio output
    // Add proper error handling for SDL initialization
    pub fn new(sample_rate: u32) -> Self {
        // Create channel for audio data
        let (sender, receiver) = channel();
        
        // Try to initialize SDL2 audio
        let device = match sdl2::init().and_then(|ctx| ctx.audio()) {
            Ok(audio_subsystem) => {
                // Configure audio
                let desired_spec = AudioSpecDesired {
                    freq: Some(sample_rate as i32),
                    channels: Some(2),  // Stereo
                    samples: Some(1024),
                };
                
                // Create audio device
                match audio_subsystem.open_playback(None, &desired_spec, |spec| {
                    debug!("Audio output initialized: {}Hz, {} channels, {} samples",
                          spec.freq, spec.channels, spec.samples);
                    
                    NesAudioCallback {
                        buffer: VecDeque::with_capacity(spec.samples as usize * 2),
                        receiver,
                    }
                }) {
                    Ok(device) => {
                        // Start audio playback
                        device.resume();
                        Some(device)
                    },
                    Err(err) => {
                        error!("Failed to open audio playback: {}", err);
                        None
                    }
                }
            },
            Err(err) => {
                error!("Failed to initialize SDL2 audio: {}", err);
                None
            }
        };
        
        AudioOutput {
            device,
            sender,
            sample_rate,
        }
    }
    
    /// Queue audio samples for playback
    pub fn queue_audio(&mut self, samples: &[Sample]) {
        if self.device.is_some() {
            if let Err(err) = self.sender.send(samples.to_vec()) {
                warn!("Failed to send audio data: {}", err);
            }
        }
    }
    
    /// Pause audio playback
    pub fn pause(&mut self) {
        if let Some(device) = &self.device {
            device.pause();
        }
    }
    
    /// Resume audio playback
    pub fn resume(&mut self) {
        if let Some(device) = &self.device {
            device.resume();
        }
    }
    
    /// Close audio device
    pub fn close(&mut self) {
        self.device = None;
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\cartridge.rs`:

```rs
//! NES cartridge implementation
//!
//! This module handles the NES cartridge format (iNES), including ROM/RAM banking
//! and mappers. The NES uses a cartridge system with separate PRG ROM (program code)
//! and CHR ROM/RAM (character/graphics data).

use std::cell::RefCell;
use std::fmt;
use std::rc::Rc;
use log::info;
use thiserror::Error;
use serde::{Serialize, Deserialize};

use crate::mappers::Mapper;
use crate::mappers::create_mapper;

/// Size of the iNES header
const INES_HEADER_SIZE: usize = 16;

/// Size of a PRG ROM bank (16KB)
const PRG_ROM_BANK_SIZE: usize = 16 * 1024;

/// Size of a CHR ROM/RAM bank (8KB)
const CHR_BANK_SIZE: usize = 8 * 1024;

/// Errors that can occur when parsing ROM files
#[derive(Error, Debug)]
pub enum ROMParseError {
    #[error("Invalid iNES header")]
    InvalidHeader,
    
    #[error("Unsupported mapper: {0}")]
    UnsupportedMapper(u8),
    
    #[error("Invalid ROM size")]
    InvalidRomSize,
    
    #[error("Trainer present but not supported")]
    TrainerNotSupported,
}

/// Mirroring modes for the NES
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Mirroring {
    /// Horizontal mirroring (vertical arrangement of nametables)
    Horizontal,
    
    /// Vertical mirroring (horizontal arrangement of nametables)
    Vertical,
    
    /// Four-screen mirroring (no mirroring)
    FourScreen,
    
    /// Single-screen mirroring, lower bank
    SingleScreenLower,
    
    /// Single-screen mirroring, upper bank
    SingleScreenUpper,
}

/// Represents an NES cartridge
pub struct Cartridge {
    /// Mapper implementation
    mapper: Rc<RefCell<Box<dyn Mapper>>>,
    
    /// Mirroring mode (from header, may be overridden by mapper)
    mirroring: Mirroring,
    
    /// Whether battery-backed RAM is present
    has_battery: bool,
    
    /// Whether NTSC or PAL is used
    is_pal: bool,
    
    /// PRG ROM size in bytes
    prg_rom_size: usize,
    
    /// CHR ROM size in bytes
    chr_rom_size: usize,
    
    /// PRG RAM size in bytes
    prg_ram_size: usize,
    
    /// Mapper number
    mapper_number: u8,
}

impl Cartridge {
    /// Create a cartridge from ROM data in iNES format
    pub fn from_bytes(data: &[u8]) -> Result<Self, ROMParseError> {
        // Check for valid iNES header
        if data.len() < INES_HEADER_SIZE || data[0..4] != [0x4E, 0x45, 0x53, 0x1A] {
            return Err(ROMParseError::InvalidHeader);
        }
        
        // Parse header
        let prg_rom_size = data[4] as usize * PRG_ROM_BANK_SIZE;
        let chr_rom_size = data[5] as usize * CHR_BANK_SIZE;
        
        let flags6 = data[6];
        let flags7 = data[7];
        let flags9 = data[9];
        
        let mirroring = if (flags6 & 0x08) != 0 {
            Mirroring::FourScreen
        } else if (flags6 & 0x01) != 0 {
            Mirroring::Vertical
        } else {
            Mirroring::Horizontal
        };
        
        let has_battery = (flags6 & 0x02) != 0;
        let has_trainer = (flags6 & 0x04) != 0;
        
        // Extract mapper number
        let mapper_low = (flags6 >> 4) & 0x0F;
        let mapper_high = flags7 & 0xF0;
        let mapper = mapper_high | mapper_low;
        
        // Check if this is an NES 2.0 format ROM
        let is_nes2 = (flags7 & 0x0C) == 0x08;
        
        // Check if PAL or NTSC
        let is_pal = (flags9 & 0x01) != 0;
        
        // Calculate PRG RAM size
        let prg_ram_size = if is_nes2 {
            // NES 2.0 format
            if data[10] & 0x0F == 0 {
                0
            } else {
                64 << ((data[10] & 0x0F) - 1)
            }
        } else {
            // iNES format
            if data[8] == 0 {
                8 * 1024 // Default to 8KB
            } else {
                data[8] as usize * 8 * 1024
            }
        };
        
        // Check if trainer is present (512 bytes before PRG ROM)
        let trainer_size = if has_trainer { 512 } else { 0 };
        
        // Check total file size
        let expected_size = INES_HEADER_SIZE + trainer_size + prg_rom_size + chr_rom_size;
        if data.len() < expected_size {
            return Err(ROMParseError::InvalidRomSize);
        }
        
        // For now, we don't support trainers
        if has_trainer {
            return Err(ROMParseError::TrainerNotSupported);
        }
        
        // For now, we only support mappers 0-4
        if mapper > 4 {
            return Err(ROMParseError::UnsupportedMapper(mapper));
        }
        
        // Load PRG ROM
        let prg_rom_start = INES_HEADER_SIZE + trainer_size;
        let prg_rom_end = prg_rom_start + prg_rom_size;
        let prg_rom = data[prg_rom_start..prg_rom_end].to_vec();
        
        // Load CHR ROM or create CHR RAM
        let chr_rom = if chr_rom_size == 0 {
            Vec::new() // CHR RAM will be created by the mapper
        } else {
            let chr_rom_start = prg_rom_end;
            let chr_rom_end = chr_rom_start + chr_rom_size;
            data[chr_rom_start..chr_rom_end].to_vec()
        };
        
        // Create PRG RAM
        let prg_ram = vec![0; prg_ram_size];
        
        // Determine CHR RAM size if CHR ROM is empty
        let chr_ram_size = if chr_rom_size == 0 {
            8 * 1024 // Default to 8KB
        } else {
            0
        };
        
        // Create mapper
        let mapper_impl = create_mapper(
            mapper,
            prg_rom,
            chr_rom,
            prg_ram,
            chr_ram_size,
            mirroring,
        );
        
        info!("Loaded cartridge - Mapper: {}, PRG ROM: {}KB, CHR {}: {}KB, Mirroring: {:?}, Battery: {}, TV System: {}",
             mapper, prg_rom_size / 1024,
             if chr_rom_size == 0 { "RAM" } else { "ROM" },
             if chr_rom_size == 0 { chr_ram_size } else { chr_rom_size } / 1024,
             mirroring, has_battery, if is_pal { "PAL" } else { "NTSC" });
        
        Ok(Cartridge {
            mapper: Rc::new(RefCell::new(mapper_impl)),
            mirroring,
            has_battery,
            is_pal,
            prg_rom_size,
            chr_rom_size,
            prg_ram_size,
            mapper_number: mapper,
        })
    }

    /// Read a byte from the cartridge (CPU space)
    pub fn read(&self, addr: u16) -> u8 {
        self.mapper.borrow().read_prg(addr)
    }

    /// Write a byte to the cartridge (CPU space)
    pub fn write(&self, addr: u16, value: u8) {
        self.mapper.borrow_mut().write_prg(addr, value);
    }

    /// Read a byte from the CHR ROM/RAM (PPU space)
    pub fn read_chr(&self, addr: u16) -> u8 {
        self.mapper.borrow().read_chr(addr)
    }

    /// Write a byte to the CHR ROM/RAM (PPU space)
    pub fn write_chr(&self, addr: u16, value: u8) {
        self.mapper.borrow_mut().write_chr(addr, value);
    }

    /// Get the current mirroring mode (may be overridden by mapper)
    pub fn get_mirroring(&self) -> Mirroring {
        self.mapper.borrow().mirroring()
    }

    /// Check if the mapper has triggered an IRQ
    pub fn irq_triggered(&self) -> bool {
        self.mapper.borrow().irq_triggered()
    }

    /// Acknowledge an IRQ
    pub fn acknowledge_irq(&self) {
        self.mapper.borrow_mut().acknowledge_irq();
    }

    /// Notify the mapper that a scanline has been completed
    pub fn notify_scanline(&self) {
        self.mapper.borrow_mut().notify_scanline();
    }

    /// Get the mapper number
    pub fn mapper_number(&self) -> u8 {
        self.mapper_number
    }

    /// Save the cartridge RAM to a byte vector (for battery-backed RAM)
    pub fn save_ram(&self) -> Vec<u8> {
        // This would be implemented to save the PRG RAM for battery-backed games
        Vec::new()
    }

    /// Load the cartridge RAM from a byte vector (for battery-backed RAM)
    pub fn load_ram(&self, data: &[u8]) {
        self.mapper.borrow_mut().load_ram(data);
    }
}

impl fmt::Debug for Cartridge {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Cartridge")
            .field("mapper", &self.mapper_number)
            .field("mirroring", &self.mirroring)
            .field("prg_rom_size", &self.prg_rom_size)
            .field("chr_rom_size", &self.chr_rom_size)
            .field("prg_ram_size", &self.prg_ram_size)
            .field("has_battery", &self.has_battery)
            .field("is_pal", &self.is_pal)
            .finish()
    }
}

pub trait CartridgeTrait {
    /// Load save RAM data
    fn load_ram(&mut self, _data: &[u8]) {
        // Default implementation does nothing
        // Override this in mappers that support save RAM
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\controller.rs`:

```rs
//! Controller implementation
//!
//! The NES has two controller ports, each supporting the standard NES controller.
//! This module handles the state of the controllers and the reading/writing of
//! controller data.

/// NES Controller
pub struct Controller {
    /// Current button state (8 buttons)
    button_state: u8,
    
    /// Shift register for serial reading
    shift_register: u8,
    
    /// Strobe flag
    strobe: bool,
}

impl Controller {
    /// Button bitmasks
    pub const BUTTON_A: u8 = 0x01;
    pub const BUTTON_B: u8 = 0x02;
    pub const BUTTON_SELECT: u8 = 0x04;
    pub const BUTTON_START: u8 = 0x08;
    pub const BUTTON_UP: u8 = 0x10;
    pub const BUTTON_DOWN: u8 = 0x20;
    pub const BUTTON_LEFT: u8 = 0x40;
    pub const BUTTON_RIGHT: u8 = 0x80;

    /// Create a new controller
    pub fn new() -> Self {
        Controller {
            button_state: 0,
            shift_register: 0,
            strobe: false,
        }
    }

    /// Reset the controller
    pub fn reset(&mut self) {
        self.button_state = 0;
        self.shift_register = 0;
        self.strobe = false;
    }

    /// Set a button state
    pub fn set_button_pressed(&mut self, button: u8, pressed: bool) {
        if pressed {
            self.button_state |= button;
        } else {
            self.button_state &= !button;
        }
    }

    /// Write to the controller (strobe)
    pub fn write(&mut self, value: u8) {
        self.strobe = (value & 0x01) != 0;
        
        if self.strobe {
            // When strobe is high, continuously reload shift register with button state
            self.shift_register = self.button_state;
        }
    }

    /// Read from the controller
    pub fn read(&mut self) -> u8 {
        if self.strobe {
            // When strobe is high, return button A state (bit 0)
            (self.button_state & 0x01) | 0xE0
        } else {
            // When strobe is low, shift out bits one at a time
            let result = self.shift_register & 0x01;
            self.shift_register = 0x80 | (self.shift_register >> 1);
            result | 0xE0
        }
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\cpu.rs`:

```rs
//! CPU implementation for the Ricoh 2A03 (modified MOS 6502)
//!
//! The 2A03 is a MOS 6502 modified for the NES, with the following changes:
//! - Decimal mode is disabled (D flag is ignored)
//! - Contains the APU (Audio Processing Unit)
//!
//! This implementation focuses on cycle-accurate timing to ensure proper
//! synchronization with other components of the NES.

use log::{debug, trace};
use crate::memory::MemoryBus;

/// Status register flag bits
#[allow(dead_code)]
pub mod flags {
    pub const CARRY: u8 = 0x01;
    pub const ZERO: u8 = 0x02;
    pub const INTERRUPT_DISABLE: u8 = 0x04;
    pub const DECIMAL: u8 = 0x08;  // Ignored on 2A03, but still settable
    pub const BREAK: u8 = 0x10;
    pub const UNUSED: u8 = 0x20;   // Always set to 1
    pub const OVERFLOW: u8 = 0x40;
    pub const NEGATIVE: u8 = 0x80;
}

/// Addressing modes for CPU instructions
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum AddressingMode {
    Implied,
    Accumulator,
    Immediate,
    ZeroPage,
    ZeroPageX,
    ZeroPageY,
    Relative,
    Absolute,
    AbsoluteX,
    AbsoluteY,
    Indirect,
    IndexedIndirect,  // (Indirect,X)
    IndirectIndexed,  // (Indirect),Y
}

/// Represents the Ricoh 2A03 CPU
pub struct CPU {
    /// Accumulator register
    pub a: u8,
    /// X index register
    pub x: u8,
    /// Y index register
    pub y: u8,
    /// Stack pointer (0x0100 - 0x01FF)
    pub sp: u8,
    /// Program counter
    pub pc: u16,
    /// Status register
    pub p: u8,
    /// Cycle count for the last instruction
    pub cycles: u8,
    /// Total cycles executed
    pub total_cycles: u64,
    /// Whether the CPU is waiting for an interrupt
    pub waiting: bool,
}

impl CPU {
    /// Create a new CPU in the reset state
    pub fn new() -> Self {
        CPU {
            a: 0,
            x: 0,
            y: 0,
            sp: 0xFD,  // Initial stack pointer value after reset
            pc: 0,     // Will be initialized from reset vector
            p: flags::UNUSED | flags::INTERRUPT_DISABLE,  // Initial status after reset
            cycles: 0,
            total_cycles: 0,
            waiting: false,
        }
    }

    /// Reset the CPU to its initial state
    pub fn reset(&mut self) {
        self.a = 0;
        self.x = 0;
        self.y = 0;
        self.sp = 0xFD;
        self.p = flags::UNUSED | flags::INTERRUPT_DISABLE;
        self.cycles = 0;
        self.total_cycles = 0;
        self.waiting = false;
        
        // The PC will be set from the reset vector during the first execution cycle
    }

    /// Execute a single CPU instruction and return the number of cycles used
    pub fn step(&mut self, bus: &mut MemoryBus) -> u32 {
        // If this is the first execution (PC = 0), read the reset vector
        if self.pc == 0 {
            let low = bus.read(0xFFFC);
            let high = bus.read(0xFFFD);
            self.pc = u16::from_le_bytes([low, high]);
            debug!("CPU reset to ${:04X}", self.pc);
            return 7; // Reset takes 7 cycles
        }
        
        // Handle interrupts
        if self.check_interrupts(bus) {
            return self.cycles as u32;
        }
        
        // Fetch instruction
        let opcode = bus.read(self.pc);
        self.pc = self.pc.wrapping_add(1);
        
        // Execute instruction
        trace!("CPU: ${:04X}: ${:02X} A:{:02X} X:{:02X} Y:{:02X} P:{:02X} SP:{:02X}",
              self.pc.wrapping_sub(1), opcode, self.a, self.x, self.y, self.p, self.sp);
        
        // Decode and execute the instruction
        self.execute_instruction(opcode, bus);
        
        // Convert cycles to u32 for return value
        let cycles_used = self.cycles as u32;
        self.total_cycles += cycles_used as u64;
        
        cycles_used
    }

    /// Check for and process any pending interrupts
    fn check_interrupts(&mut self, bus: &mut MemoryBus) -> bool {
        // NMI has highest priority
        if bus.peek_nmi() {
            self.handle_nmi(bus);
            return true;
        }
        
        // IRQ is next if interrupts are enabled
        if bus.peek_irq() && (self.p & flags::INTERRUPT_DISABLE) == 0 {
            self.handle_irq(bus);
            return true;
        }
        
        false
    }

    /// Handle a non-maskable interrupt (NMI)
    fn handle_nmi(&mut self, bus: &mut MemoryBus) {
        bus.acknowledge_nmi();
        
        // Push PC and processor status to stack
        self.push_word(bus, self.pc);
        self.push_byte(bus, self.p & !flags::BREAK);
        
        // Set the interrupt flag
        self.p |= flags::INTERRUPT_DISABLE;
        
        // Load the NMI vector
        let low = bus.read(0xFFFA);
        let high = bus.read(0xFFFB);
        self.pc = u16::from_le_bytes([low, high]);
        
        // NMI takes 7 cycles
        self.cycles = 7;
        
        debug!("NMI handled, jumping to ${:04X}", self.pc);
    }

    /// Handle an interrupt request (IRQ)
    fn handle_irq(&mut self, bus: &mut MemoryBus) {
        bus.acknowledge_irq();
        
        // Push PC and processor status to stack
        self.push_word(bus, self.pc);
        self.push_byte(bus, self.p & !flags::BREAK);
        
        // Set the interrupt flag
        self.p |= flags::INTERRUPT_DISABLE;
        
        // Load the IRQ vector
        let low = bus.read(0xFFFE);
        let high = bus.read(0xFFFF);
        self.pc = u16::from_le_bytes([low, high]);
        
        // IRQ takes 7 cycles
        self.cycles = 7;
        
        debug!("IRQ handled, jumping to ${:04X}", self.pc);
    }

    /// Push a byte onto the stack
    fn push_byte(&mut self, bus: &mut MemoryBus, value: u8) {
        bus.write(0x0100 + u16::from(self.sp), value);
        self.sp = self.sp.wrapping_sub(1);
    }

    /// Push a word (2 bytes) onto the stack
    fn push_word(&mut self, bus: &mut MemoryBus, value: u16) {
        let [low, high] = value.to_le_bytes();
        self.push_byte(bus, high);
        self.push_byte(bus, low);
    }

    /// Pop a byte from the stack
    fn pop_byte(&mut self, bus: &mut MemoryBus) -> u8 {
        self.sp = self.sp.wrapping_add(1);
        bus.read(0x0100 + u16::from(self.sp))
    }

    /// Pop a word (2 bytes) from the stack
    fn pop_word(&mut self, bus: &mut MemoryBus) -> u16 {
        let low = self.pop_byte(bus);
        let high = self.pop_byte(bus);
        u16::from_le_bytes([low, high])
    }

    /// Get the address for the given addressing mode
    fn get_address(&mut self, mode: AddressingMode, bus: &mut MemoryBus) -> u16 {
        match mode {
            AddressingMode::Implied | AddressingMode::Accumulator => {
                0 // Not used for these modes
            }
            AddressingMode::Immediate => {
                let addr = self.pc;
                self.pc = self.pc.wrapping_add(1);
                addr
            }
            AddressingMode::ZeroPage => {
                let addr = bus.read(self.pc) as u16;
                self.pc = self.pc.wrapping_add(1);
                addr
            }
            AddressingMode::ZeroPageX => {
                let base = bus.read(self.pc);
                self.pc = self.pc.wrapping_add(1);
                (base.wrapping_add(self.x)) as u16
            }
            AddressingMode::ZeroPageY => {
                let base = bus.read(self.pc);
                self.pc = self.pc.wrapping_add(1);
                (base.wrapping_add(self.y)) as u16
            }
            AddressingMode::Relative => {
                let offset = bus.read(self.pc) as i8;
                self.pc = self.pc.wrapping_add(1);
                self.pc.wrapping_add(offset as u16)
            }
            AddressingMode::Absolute => {
                let low = bus.read(self.pc);
                let high = bus.read(self.pc.wrapping_add(1));
                self.pc = self.pc.wrapping_add(2);
                u16::from_le_bytes([low, high])
            }
            AddressingMode::AbsoluteX => {
                let low = bus.read(self.pc);
                let high = bus.read(self.pc.wrapping_add(1));
                self.pc = self.pc.wrapping_add(2);
                let base = u16::from_le_bytes([low, high]);
                base.wrapping_add(self.x as u16)
            }
            AddressingMode::AbsoluteY => {
                let low = bus.read(self.pc);
                let high = bus.read(self.pc.wrapping_add(1));
                self.pc = self.pc.wrapping_add(2);
                let base = u16::from_le_bytes([low, high]);
                base.wrapping_add(self.y as u16)
            }
            AddressingMode::Indirect => {
                let low = bus.read(self.pc);
                let high = bus.read(self.pc.wrapping_add(1));
                self.pc = self.pc.wrapping_add(2);
                let ptr = u16::from_le_bytes([low, high]);
                
                // Replicate 6502 indirect JMP bug for page crossing
                let target_low = bus.read(ptr);
                let target_high = if low == 0xFF {
                    bus.read(ptr & 0xFF00)
                } else {
                    bus.read(ptr.wrapping_add(1))
                };
                
                u16::from_le_bytes([target_low, target_high])
            }
            AddressingMode::IndexedIndirect => {
                let base = bus.read(self.pc);
                self.pc = self.pc.wrapping_add(1);
                let ptr = base.wrapping_add(self.x) as u16;
                
                let low = bus.read(ptr);
                let high = bus.read(ptr.wrapping_add(1) & 0xFF);
                
                u16::from_le_bytes([low, high])
            }
            AddressingMode::IndirectIndexed => {
                let base = bus.read(self.pc) as u16;
                self.pc = self.pc.wrapping_add(1);
                
                let low = bus.read(base);
                let high = bus.read((base + 1) & 0xFF);
                
                let addr = u16::from_le_bytes([low, high]);
                addr.wrapping_add(self.y as u16)
            }
        }
    }

    /// Execute an instruction with the given opcode
    fn execute_instruction(&mut self, opcode: u8, bus: &mut MemoryBus) {
        match opcode {
            // This is a simplified implementation with just a few common instructions
            // In a complete implementation, all 151 valid 6502 opcodes should be handled
            
            // LDA - Load Accumulator
            0xA9 => self.lda(AddressingMode::Immediate, bus),
            0xA5 => self.lda(AddressingMode::ZeroPage, bus),
            0xB5 => self.lda(AddressingMode::ZeroPageX, bus),
            0xAD => self.lda(AddressingMode::Absolute, bus),
            0xBD => self.lda(AddressingMode::AbsoluteX, bus),
            0xB9 => self.lda(AddressingMode::AbsoluteY, bus),
            0xA1 => self.lda(AddressingMode::IndexedIndirect, bus),
            0xB1 => self.lda(AddressingMode::IndirectIndexed, bus),

            // LDX - Load X Register
            0xA2 => self.ldx(AddressingMode::Immediate, bus),
            0xA6 => self.ldx(AddressingMode::ZeroPage, bus),
            0xB6 => self.ldx(AddressingMode::ZeroPageY, bus),
            0xAE => self.ldx(AddressingMode::Absolute, bus),
            0xBE => self.ldx(AddressingMode::AbsoluteY, bus),
            
            // LDY - Load Y Register
            0xA0 => self.ldy(AddressingMode::Immediate, bus),
            0xA4 => self.ldy(AddressingMode::ZeroPage, bus),
            0xB4 => self.ldy(AddressingMode::ZeroPageX, bus),
            0xAC => self.ldy(AddressingMode::Absolute, bus),
            0xBC => self.ldy(AddressingMode::AbsoluteX, bus),
            
            // STA - Store Accumulator
            0x85 => self.sta(AddressingMode::ZeroPage, bus),
            0x95 => self.sta(AddressingMode::ZeroPageX, bus),
            0x8D => self.sta(AddressingMode::Absolute, bus),
            0x9D => self.sta(AddressingMode::AbsoluteX, bus),
            0x99 => self.sta(AddressingMode::AbsoluteY, bus),
            0x81 => self.sta(AddressingMode::IndexedIndirect, bus),
            0x91 => self.sta(AddressingMode::IndirectIndexed, bus),
            
            // STX - Store X Register
            0x86 => self.stx(AddressingMode::ZeroPage, bus),
            0x96 => self.stx(AddressingMode::ZeroPageY, bus),
            0x8E => self.stx(AddressingMode::Absolute, bus),
            
            // STY - Store Y Register
            0x84 => self.sty(AddressingMode::ZeroPage, bus),
            0x94 => self.sty(AddressingMode::ZeroPageX, bus),
            0x8C => self.sty(AddressingMode::Absolute, bus),
            
            // JMP - Jump
            0x4C => self.jmp(AddressingMode::Absolute, bus),
            0x6C => self.jmp(AddressingMode::Indirect, bus),
            
            // JSR - Jump to Subroutine
            0x20 => self.jsr(bus),
            
            // RTS - Return from Subroutine
            0x60 => self.rts(bus),
            
            // BCC - Branch if Carry Clear
            0x90 => self.bcc(bus),
            
            // BCS - Branch if Carry Set
            0xB0 => self.bcs(bus),
            
            // BEQ - Branch if Equal (Zero Set)
            0xF0 => self.beq(bus),
            
            // BNE - Branch if Not Equal (Zero Clear)
            0xD0 => self.bne(bus),
            
            // BVC - Branch if Overflow Clear
            0x50 => self.bvc(bus),
            
            // BVS - Branch if Overflow Set
            0x70 => self.bvs(bus),
            
            // BPL - Branch if Plus (Negative Clear)
            0x10 => self.bpl(bus),
            
            // BMI - Branch if Minus (Negative Set)
            0x30 => self.bmi(bus),
            
            // CLC - Clear Carry Flag
            0x18 => {
                self.p &= !flags::CARRY;
                self.cycles = 2;
            },
            
            // SEC - Set Carry Flag
            0x38 => {
                self.p |= flags::CARRY;
                self.cycles = 2;
            },
            
            // CLI - Clear Interrupt Disable
            0x58 => {
                self.p &= !flags::INTERRUPT_DISABLE;
                self.cycles = 2;
            },
            
            // SEI - Set Interrupt Disable
            0x78 => {
                self.p |= flags::INTERRUPT_DISABLE;
                self.cycles = 2;
            },
            
            // CLD - Clear Decimal Mode
            0xD8 => {
                self.p &= !flags::DECIMAL;
                self.cycles = 2;
                // Note: On the 2A03, the decimal flag can be set but decimal mode
                // does not function, as it was disabled by Nintendo.
            },
            
            // SED - Set Decimal Mode
            0xF8 => {
                self.p |= flags::DECIMAL;
                self.cycles = 2;
                // Note: On the 2A03, the decimal flag can be set but decimal mode
                // does not function, as it was disabled by Nintendo.
            },
            
            // CLV - Clear Overflow Flag
            0xB8 => {
                self.p &= !flags::OVERFLOW;
                self.cycles = 2;
            },
            
            // NOP - No Operation
            0xEA => {
                self.cycles = 2;
            },

            // This is a simplified instruction set for brevity.
            // In a complete implementation, all 151 valid opcodes would be handled here.
            // The remaining instructions (ADC, SBC, AND, ORA, EOR, etc.) would follow
            // similar patterns to those shown above.
            
            _ => {
                // Illegal/unimplemented opcode
                debug!("Unimplemented opcode: ${:02X} at ${:04X}", opcode, self.pc - 1);
                self.cycles = 2; // Default to 2 cycles
            }
        }
    }

    // Implementation of individual instructions
    
    /// LDA - Load Accumulator
    fn lda(&mut self, mode: AddressingMode, bus: &mut MemoryBus) {
        let addr = self.get_address(mode, bus);
        let value = if mode == AddressingMode::Immediate {
            bus.read(addr)
        } else {
            bus.read(addr)
        };
        
        self.a = value;
        
        // Set zero and negative flags
        self.p = (self.p & !(flags::ZERO | flags::NEGATIVE))
            | if self.a == 0 { flags::ZERO } else { 0 }
            | (self.a & flags::NEGATIVE);
        
        // Set cycles based on addressing mode
        self.cycles = match mode {
            AddressingMode::Immediate => 2,
            AddressingMode::ZeroPage => 3,
            AddressingMode::ZeroPageX => 4,
            AddressingMode::Absolute => 4,
            AddressingMode::AbsoluteX | AddressingMode::AbsoluteY => {
                // Add 1 cycle if page boundary is crossed
                if (addr & 0xFF00) != ((addr - (if mode == AddressingMode::AbsoluteX { self.x } else { self.y }) as u16) & 0xFF00) {
                    5
                } else {
                    4
                }
            },
            AddressingMode::IndexedIndirect => 6,
            AddressingMode::IndirectIndexed => {
                // Add 1 cycle if page boundary is crossed
                let base_addr = self.get_address(AddressingMode::ZeroPage, bus);
                let indirect_addr = u16::from_le_bytes([
                    bus.read(base_addr),
                    bus.read((base_addr + 1) & 0xFF),
                ]);
                
                if (addr & 0xFF00) != (indirect_addr & 0xFF00) {
                    6
                } else {
                    5
                }
            },
            _ => panic!("Invalid addressing mode for LDA: {:?}", mode),
        };
    }

    /// LDX - Load X Register
    fn ldx(&mut self, mode: AddressingMode, bus: &mut MemoryBus) {
        let addr = self.get_address(mode, bus);
        let value = if mode == AddressingMode::Immediate {
            bus.read(addr)
        } else {
            bus.read(addr)
        };
        
        self.x = value;
        
        // Set zero and negative flags
        self.p = (self.p & !(flags::ZERO | flags::NEGATIVE))
            | if self.x == 0 { flags::ZERO } else { 0 }
            | (self.x & flags::NEGATIVE);
        
        // Set cycles based on addressing mode
        self.cycles = match mode {
            AddressingMode::Immediate => 2,
            AddressingMode::ZeroPage => 3,
            AddressingMode::ZeroPageY => 4,
            AddressingMode::Absolute => 4,
            AddressingMode::AbsoluteY => {
                // Add 1 cycle if page boundary is crossed
                if (addr & 0xFF00) != ((addr - self.y as u16) & 0xFF00) {
                    5
                } else {
                    4
                }
            },
            _ => panic!("Invalid addressing mode for LDX: {:?}", mode),
        };
    }

    /// LDY - Load Y Register
    fn ldy(&mut self, mode: AddressingMode, bus: &mut MemoryBus) {
        let addr = self.get_address(mode, bus);
        let value = if mode == AddressingMode::Immediate {
            bus.read(addr)
        } else {
            bus.read(addr)
        };
        
        self.y = value;
        
        // Set zero and negative flags
        self.p = (self.p & !(flags::ZERO | flags::NEGATIVE))
            | if self.y == 0 { flags::ZERO } else { 0 }
            | (self.y & flags::NEGATIVE);
        
        // Set cycles based on addressing mode
        self.cycles = match mode {
            AddressingMode::Immediate => 2,
            AddressingMode::ZeroPage => 3,
            AddressingMode::ZeroPageX => 4,
            AddressingMode::Absolute => 4,
            AddressingMode::AbsoluteX => {
                // Add 1 cycle if page boundary is crossed
                if (addr & 0xFF00) != ((addr - self.x as u16) & 0xFF00) {
                    5
                } else {
                    4
                }
            },
            _ => panic!("Invalid addressing mode for LDY: {:?}", mode),
        };
    }

    /// STA - Store Accumulator
    fn sta(&mut self, mode: AddressingMode, bus: &mut MemoryBus) {
        let addr = self.get_address(mode, bus);
        bus.write(addr, self.a);
        
        // Set cycles based on addressing mode
        self.cycles = match mode {
            AddressingMode::ZeroPage => 3,
            AddressingMode::ZeroPageX => 4,
            AddressingMode::Absolute => 4,
            AddressingMode::AbsoluteX => 5,
            AddressingMode::AbsoluteY => 5,
            AddressingMode::IndexedIndirect => 6,
            AddressingMode::IndirectIndexed => 6,
            _ => panic!("Invalid addressing mode for STA: {:?}", mode),
        };
    }

    /// STX - Store X Register
    fn stx(&mut self, mode: AddressingMode, bus: &mut MemoryBus) {
        let addr = self.get_address(mode, bus);
        bus.write(addr, self.x);
        
        // Set cycles based on addressing mode
        self.cycles = match mode {
            AddressingMode::ZeroPage => 3,
            AddressingMode::ZeroPageY => 4,
            AddressingMode::Absolute => 4,
            _ => panic!("Invalid addressing mode for STX: {:?}", mode),
        };
    }

    /// STY - Store Y Register
    fn sty(&mut self, mode: AddressingMode, bus: &mut MemoryBus) {
        let addr = self.get_address(mode, bus);
        bus.write(addr, self.y);
        
        // Set cycles based on addressing mode
        self.cycles = match mode {
            AddressingMode::ZeroPage => 3,
            AddressingMode::ZeroPageX => 4,
            AddressingMode::Absolute => 4,
            _ => panic!("Invalid addressing mode for STY: {:?}", mode),
        };
    }

    /// JMP - Jump
    fn jmp(&mut self, mode: AddressingMode, bus: &mut MemoryBus) {
        let addr = self.get_address(mode, bus);
        self.pc = addr;
        
        // Set cycles based on addressing mode
        self.cycles = match mode {
            AddressingMode::Absolute => 3,
            AddressingMode::Indirect => 5,
            _ => panic!("Invalid addressing mode for JMP: {:?}", mode),
        };
    }

    /// JSR - Jump to Subroutine
    fn jsr(&mut self, bus: &mut MemoryBus) {
        let target = self.get_address(AddressingMode::Absolute, bus);
        
        // Push the return address (PC - 1) to the stack
        self.push_word(bus, self.pc.wrapping_sub(1));
        
        // Jump to the target address
        self.pc = target;
        
        // JSR takes 6 cycles
        self.cycles = 6;
    }

    /// RTS - Return from Subroutine
    fn rts(&mut self, bus: &mut MemoryBus) {
        // Pop the return address from the stack
        let addr = self.pop_word(bus);
        
        // Set PC to the return address + 1
        self.pc = addr.wrapping_add(1);
        
        // RTS takes 6 cycles
        self.cycles = 6;
    }

    /// Branch instructions
    
    /// BCC - Branch if Carry Clear
    fn bcc(&mut self, bus: &mut MemoryBus) {
        let target = self.get_address(AddressingMode::Relative, bus);
        
        // Check if the carry flag is clear
        if (self.p & flags::CARRY) == 0 {
            // Branch taken - additional cycle
            self.cycles = 3;
            
            // Check if page boundary is crossed
            if (self.pc & 0xFF00) != (target & 0xFF00) {
                self.cycles += 1;
            }
            
            self.pc = target;
        } else {
            // Branch not taken
            self.cycles = 2;
        }
    }

    /// BCS - Branch if Carry Set
    fn bcs(&mut self, bus: &mut MemoryBus) {
        let target = self.get_address(AddressingMode::Relative, bus);
        
        // Check if the carry flag is set
        if (self.p & flags::CARRY) != 0 {
            // Branch taken - additional cycle
            self.cycles = 3;
            
            // Check if page boundary is crossed
            if (self.pc & 0xFF00) != (target & 0xFF00) {
                self.cycles += 1;
            }
            
            self.pc = target;
        } else {
            // Branch not taken
            self.cycles = 2;
        }
    }

    /// BEQ - Branch if Equal (Zero Set)
    fn beq(&mut self, bus: &mut MemoryBus) {
        let target = self.get_address(AddressingMode::Relative, bus);
        
        // Check if the zero flag is set
        if (self.p & flags::ZERO) != 0 {
            // Branch taken - additional cycle
            self.cycles = 3;
            
            // Check if page boundary is crossed
            if (self.pc & 0xFF00) != (target & 0xFF00) {
                self.cycles += 1;
            }
            
            self.pc = target;
        } else {
            // Branch not taken
            self.cycles = 2;
        }
    }

    /// BNE - Branch if Not Equal (Zero Clear)
    fn bne(&mut self, bus: &mut MemoryBus) {
        let target = self.get_address(AddressingMode::Relative, bus);
        
        // Check if the zero flag is clear
        if (self.p & flags::ZERO) == 0 {
            // Branch taken - additional cycle
            self.cycles = 3;
            
            // Check if page boundary is crossed
            if (self.pc & 0xFF00) != (target & 0xFF00) {
                self.cycles += 1;
            }
            
            self.pc = target;
        } else {
            // Branch not taken
            self.cycles = 2;
        }
    }

    /// BVC - Branch if Overflow Clear
    fn bvc(&mut self, bus: &mut MemoryBus) {
        let target = self.get_address(AddressingMode::Relative, bus);
        
        // Check if the overflow flag is clear
        if (self.p & flags::OVERFLOW) == 0 {
            // Branch taken - additional cycle
            self.cycles = 3;
            
            // Check if page boundary is crossed
            if (self.pc & 0xFF00) != (target & 0xFF00) {
                self.cycles += 1;
            }
            
            self.pc = target;
        } else {
            // Branch not taken
            self.cycles = 2;
        }
    }

    /// BVS - Branch if Overflow Set
    fn bvs(&mut self, bus: &mut MemoryBus) {
        let target = self.get_address(AddressingMode::Relative, bus);
        
        // Check if the overflow flag is set
        if (self.p & flags::OVERFLOW) != 0 {
            // Branch taken - additional cycle
            self.cycles = 3;
            
            // Check if page boundary is crossed
            if (self.pc & 0xFF00) != (target & 0xFF00) {
                self.cycles += 1;
            }
            
            self.pc = target;
        } else {
            // Branch not taken
            self.cycles = 2;
        }
    }

    /// BPL - Branch if Plus (Negative Clear)
    fn bpl(&mut self, bus: &mut MemoryBus) {
        let target = self.get_address(AddressingMode::Relative, bus);
        
        // Check if the negative flag is clear
        if (self.p & flags::NEGATIVE) == 0 {
            // Branch taken - additional cycle
            self.cycles = 3;
            
            // Check if page boundary is crossed
            if (self.pc & 0xFF00) != (target & 0xFF00) {
                self.cycles += 1;
            }
            
            self.pc = target;
        } else {
            // Branch not taken
            self.cycles = 2;
        }
    }

    /// BMI - Branch if Minus (Negative Set)
    fn bmi(&mut self, bus: &mut MemoryBus) {
        let target = self.get_address(AddressingMode::Relative, bus);
        
        // Check if the negative flag is set
        if (self.p & flags::NEGATIVE) != 0 {
            // Branch taken - additional cycle
            self.cycles = 3;
            
            // Check if page boundary is crossed
            if (self.pc & 0xFF00) != (target & 0xFF00) {
                self.cycles += 1;
            }
            
            self.pc = target;
        } else {
            // Branch not taken
            self.cycles = 2;
        }
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\main.rs`:

```rs
//! RustyNES - A cycle-accurate Nintendo Entertainment System emulator
//!
//! This is the main entry point for the emulator. It handles command-line arguments,
//! initializes the system, loads ROMs, and runs the main emulation loop.

use anyhow::{Context, Result};
use clap::Parser;
use log::{error, info};
use std::path::PathBuf;

mod apu;
mod audio;
mod cartridge;
mod cpu;
mod mappers;
mod memory;
mod nes;
mod ppu;
mod controller;
// mod savestate;
mod util;

use nes::NES;
use ppu::TVSystem;

/// Command line arguments for RustyNES
#[derive(Parser, Debug)]
#[clap(author, version, about)]
struct Args {
    /// Path to the NES ROM file
    #[clap(name = "ROM")]
    rom_path: PathBuf,

    /// Enable debug logging
    #[clap(short, long)]
    debug: bool,
    
    /// Use PAL TV system instead of NTSC
    #[clap(long)]
    pal: bool,
    
    /// Scale factor for display (default: 3)
    #[clap(short, long, default_value = "3")]
    scale: u32,
}

fn main() -> Result<()> {
    // Parse command line arguments
    let args = Args::parse();

    // Initialize logging
    if args.debug {
        env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("debug")).init();
    } else {
        env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info")).init();
    }

    info!("RustyNES emulator starting...");
    
    // Determine TV system
    let tv_system = if args.pal {
        TVSystem::PAL
    } else {
        TVSystem::NTSC
    };
    
    // Create and initialize the NES
    let mut nes = NES::new(tv_system);
    
    // Load the ROM file
    let rom_path = args.rom_path.to_string_lossy();
    info!("Loading ROM: {}", rom_path);
    
    nes.load_cartridge_from_file(&args.rom_path)
        .with_context(|| format!("Failed to load ROM: {}", rom_path))?;
    
    // Run the emulator
    match nes.run() {
        Ok(_) => {
            info!("Emulation completed successfully");
            Ok(())
        }
        Err(e) => {
            error!("Emulation error: {}", e);
            Err(e)
        }
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\mappers\mapper000.rs`:

```rs
//! Mapper 000 (NROM) implementation
//!
//! This is the simplest NES mapper with no banking capabilities.
//! Used by games like Super Mario Bros, Donkey Kong, etc.
//!
//! Memory map:
//! - PRG ROM: 16KB (0x8000-0xBFFF) or 32KB (0x8000-0xFFFF)
//! - CHR ROM/RAM: 8KB (0x0000-0x1FFF)

use crate::cartridge::{Mirroring, CartridgeTrait};
use super::Mapper;

pub struct Mapper000 {
    /// PRG ROM data
    prg_rom: Vec<u8>,
    
    /// CHR ROM/RAM data
    chr: Vec<u8>,
    
    /// Whether CHR is RAM (writable) or ROM (read-only)
    chr_is_ram: bool,
    
    /// Mirroring mode
    mirroring: Mirroring,
}

impl Mapper000 {
    /// Create a new Mapper000 instance
    pub fn new(prg_rom: Vec<u8>, chr_rom: Vec<u8>, chr_ram_size: usize, mirroring: Mirroring) -> Self {
        let chr_is_ram = chr_rom.is_empty();
        let chr = if chr_is_ram {
            vec![0; chr_ram_size]
        } else {
            chr_rom
        };
        
        Mapper000 {
            prg_rom,
            chr,
            chr_is_ram,
            mirroring,
        }
    }
}

impl Mapper for Mapper000 {
    fn read_prg(&self, addr: u16) -> u8 {
        let mask = if self.prg_rom.len() <= 16 * 1024 { 0x3FFF } else { 0x7FFF };
        self.prg_rom[(addr & mask) as usize]
    }
    
    fn write_prg(&mut self, _addr: u16, _data: u8) {
        // PRG ROM is read-only in NROM
    }
    
    fn read_chr(&self, addr: u16) -> u8 {
        self.chr[(addr & 0x1FFF) as usize]
    }
    
    fn write_chr(&mut self, addr: u16, data: u8) {
        if self.chr_is_ram {
            self.chr[(addr & 0x1FFF) as usize] = data;
        }
    }
    
    fn mirroring(&self) -> Mirroring {
        self.mirroring
    }
    
    fn irq_triggered(&self) -> bool {
        false
    }
    
    fn acknowledge_irq(&mut self) {
        // No IRQ in NROM
    }
    
    fn notify_scanline(&mut self) {
        // No scanline counter in NROM
    }
    
    fn reset(&mut self) {
        // Nothing to reset in NROM
    }
}

impl CartridgeTrait for Mapper000 {
    fn load_ram(&mut self, _data: &[u8]) {
        // NROM has no PRG RAM
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\mappers\mapper001.rs`:

```rs
//! Mapper 001 (MMC1) implementation
//!
//! This mapper features PRG ROM banking, CHR ROM banking, and configurable mirroring.
//! Used by games like The Legend of Zelda, Metroid, Final Fantasy, etc.
//!
//! Memory map:
//! - PRG ROM: 16KB/32KB with banking
//! - PRG RAM: 8KB (0x6000-0x7FFF)
//! - CHR ROM/RAM: 8KB with banking

use log::debug;
use crate::cartridge::{Mirroring, CartridgeTrait};
use super::Mapper;

pub struct Mapper001 {
    /// PRG ROM data
    prg_rom: Vec<u8>,
    
    /// CHR ROM/RAM data
    chr: Vec<u8>,
    
    /// PRG RAM data
    prg_ram: Vec<u8>,
    
    /// Whether CHR is RAM (writable) or ROM (read-only)
    chr_is_ram: bool,
    
    /// Shift register for serial MMC1 writes
    shift_register: u8,
    
    /// Shift register bit counter
    shift_count: u8,
    
    /// Control register (0x8000-0x9FFF)
    /// - Bits 0-1: Mirroring
    /// - Bit 2: PRG ROM bank mode
    /// - Bits 3-4: CHR ROM bank mode
    control: u8,
    
    /// CHR bank 0 register (0xA000-0xBFFF)
    chr_bank_0: u8,
    
    /// CHR bank 1 register (0xC000-0xDFFF)
    chr_bank_1: u8,
    
    /// PRG bank register (0xE000-0xFFFF)
    prg_bank: u8,
    
    /// Mirroring mode
    mirroring: Mirroring,
}

impl Mapper001 {
    /// Create a new Mapper001 instance
    pub fn new(prg_rom: Vec<u8>, chr_rom: Vec<u8>, prg_ram: Vec<u8>, mirroring: Mirroring) -> Self {
        let chr_is_ram = chr_rom.is_empty();
        let chr = if chr_is_ram {
            vec![0; 8 * 1024] // 8KB CHR RAM
        } else {
            chr_rom
        };
        
        Mapper001 {
            prg_rom,
            chr,
            prg_ram,
            chr_is_ram,
            shift_register: 0x10, // Reset state
            shift_count: 0,
            control: 0x0C,       // Initial control value
            chr_bank_0: 0,
            chr_bank_1: 0,
            prg_bank: 0,
            mirroring,
        }
    }
    
    /// Get the PRG ROM bank size
    fn prg_bank_size(&self) -> usize {
        16 * 1024 // 16KB banks
    }
    
    /// Get the CHR bank size
    fn chr_bank_size(&self) -> usize {
        4 * 1024 // 4KB banks
    }
    
    /// Get the address for PRG ROM access
    fn prg_addr(&self, addr: u16) -> usize {
        let prg_bank_count = self.prg_rom.len() / self.prg_bank_size();
        
        match (self.control >> 2) & 0x03 {
            0 | 1 => {
                // 32KB mode (ignore bit 0)
                let bank = (self.prg_bank & 0x0E) % (prg_bank_count as u8 & 0xFE);
                let bank_offset = ((addr & 0x7FFF) + (bank as u16 * 0x8000)) as usize;
                bank_offset % self.prg_rom.len()
            },
            2 => {
                // Fixed first bank, switchable second bank
                if addr < 0xC000 {
                    (addr & 0x3FFF) as usize
                } else {
                    let bank = self.prg_bank % prg_bank_count as u8;
                    let bank_offset = ((addr & 0x3FFF) + (bank as u16 * 0x4000)) as usize;
                    bank_offset % self.prg_rom.len()
                }
            },
            3 => {
                // Switchable first bank, fixed last bank
                if addr >= 0xC000 {
                    let bank = (prg_bank_count - 1) as u8;
                    let bank_offset = ((addr & 0x3FFF) + (bank as u16 * 0x4000)) as usize;
                    bank_offset % self.prg_rom.len()
                } else {
                    let bank = self.prg_bank % prg_bank_count as u8;
                    let bank_offset = ((addr & 0x3FFF) + (bank as u16 * 0x4000)) as usize;
                    bank_offset % self.prg_rom.len()
                }
            },
            _ => unreachable!(),
        }
    }
    
    /// Get the address for CHR ROM/RAM access
    fn chr_addr(&self, addr: u16) -> usize {
        let chr_bank_count = self.chr.len() / self.chr_bank_size();
        
        match (self.control >> 4) & 0x01 {
            0 => {
                // 8KB mode
                let bank = (self.chr_bank_0 & 0x1E) % (chr_bank_count as u8 & 0xFE);
                let bank_offset = (addr + (bank as u16 * 0x2000)) as usize;
                bank_offset % self.chr.len()
            },
            1 => {
                // 4KB mode
                if addr < 0x1000 {
                    let bank = self.chr_bank_0 % chr_bank_count as u8;
                    let bank_offset = (addr + (bank as u16 * 0x1000)) as usize;
                    bank_offset % self.chr.len()
                } else {
                    let bank = self.chr_bank_1 % chr_bank_count as u8;
                    let bank_offset = ((addr & 0x0FFF) + (bank as u16 * 0x1000)) as usize;
                    bank_offset % self.chr.len()
                }
            },
            _ => unreachable!(),
        }
    }
    
    /// Update the mirroring mode based on the control register
    fn update_mirroring(&mut self) {
        self.mirroring = match self.control & 0x03 {
            0 => Mirroring::SingleScreenLower,
            1 => Mirroring::SingleScreenUpper,
            2 => Mirroring::Vertical,
            3 => Mirroring::Horizontal,
            _ => unreachable!(),
        };
    }
    
    /// Write to a mapper register
    fn write_register(&mut self, addr: u16, data: u8) {
        // Register area is selected by bits 13-14 of the address
        match (addr >> 13) & 0x03 {
            0 => {
                // Control register (0x8000-0x9FFF)
                self.control = data;
                self.update_mirroring();
            },
            1 => {
                // CHR bank 0 register (0xA000-0xBFFF)
                self.chr_bank_0 = data;
            },
            2 => {
                // CHR bank 1 register (0xC000-0xDFFF)
                self.chr_bank_1 = data;
            },
            3 => {
                // PRG bank register (0xE000-0xFFFF)
                self.prg_bank = data & 0x0F;
            },
            _ => unreachable!(),
        }
        
        debug!("MMC1 Register update: addr=${:04X}, data=${:02X}, control=${:02X}, chr0=${:02X}, chr1=${:02X}, prg=${:02X}",
              addr, data, self.control, self.chr_bank_0, self.chr_bank_1, self.prg_bank);
    }
}

impl Mapper for Mapper001 {
    fn read_prg(&self, addr: u16) -> u8 {
        match addr {
            0x6000..=0x7FFF => {
                // PRG RAM
                let ram_addr = (addr & 0x1FFF) as usize;
                if ram_addr < self.prg_ram.len() {
                    self.prg_ram[ram_addr]
                } else {
                    0
                }
            },
            0x8000..=0xFFFF => {
                // PRG ROM
                let rom_addr = self.prg_addr(addr);
                self.prg_rom[rom_addr]
            },
            _ => 0,
        }
    }
    
    fn write_prg(&mut self, addr: u16, data: u8) {
        match addr {
            0x6000..=0x7FFF => {
                // PRG RAM
                let ram_addr = (addr & 0x1FFF) as usize;
                if ram_addr < self.prg_ram.len() {
                    self.prg_ram[ram_addr] = data;
                }
            },
            0x8000..=0xFFFF => {
                // Mapper registers
                // Reset on bit 7 set
                if (data & 0x80) != 0 {
                    self.shift_register = 0x10;
                    self.shift_count = 0;
                    self.control |= 0x0C;
                    return;
                }
                
                // Serial shift register
                self.shift_register >>= 1;
                self.shift_register |= (data & 0x01) << 4;
                self.shift_count += 1;
                
                // If 5 bits have been written, update the register
                if self.shift_count == 5 {
                    self.write_register(addr, self.shift_register);
                    self.shift_register = 0x10;
                    self.shift_count = 0;
                }
            },
            _ => {},
        }
    }
    
    fn read_chr(&self, addr: u16) -> u8 {
        let chr_addr = self.chr_addr(addr);
        self.chr[chr_addr]
    }
    
    fn write_chr(&mut self, addr: u16, data: u8) {
        if self.chr_is_ram {
            let chr_addr = self.chr_addr(addr);
            self.chr[chr_addr] = data;
        }
    }
    
    fn mirroring(&self) -> Mirroring {
        self.mirroring
    }
    
    fn irq_triggered(&self) -> bool {
        false // MMC1 doesn't generate IRQs
    }
    
    fn acknowledge_irq(&mut self) {
        // No IRQs in MMC1
    }
    
    fn notify_scanline(&mut self) {
        // No scanline counter in MMC1
    }
    
    fn reset(&mut self) {
        self.shift_register = 0x10;
        self.shift_count = 0;
        self.control = 0x0C;
        self.chr_bank_0 = 0;
        self.chr_bank_1 = 0;
        self.prg_bank = 0;
        self.update_mirroring();
    }
}

impl CartridgeTrait for Mapper001 {
    fn load_ram(&mut self, data: &[u8]) {
        if !data.is_empty() && data.len() <= self.prg_ram.len() {
            self.prg_ram[..data.len()].copy_from_slice(data);
        }
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\mappers\mapper002.rs`:

```rs
//! Mapper 002 (UxROM) implementation
//!
//! This mapper features PRG ROM banking with fixed last bank.
//! Used by games like Mega Man, Duck Tales, Castlevania, etc.
//!
//! Memory map:
//! - PRG ROM: Switchable 16KB bank + fixed 16KB bank
//! - CHR ROM/RAM: 8KB (fixed)

use crate::cartridge::{Mirroring, CartridgeTrait};
use super::Mapper;

pub struct Mapper002 {
    /// PRG ROM data
    prg_rom: Vec<u8>,
    
    /// CHR ROM/RAM data
    chr: Vec<u8>,
    
    /// Whether CHR is RAM (writable) or ROM (read-only)
    chr_is_ram: bool,
    
    /// Current PRG ROM bank
    prg_bank: u8,
    
    /// Mirroring mode
    mirroring: Mirroring,
}

impl Mapper002 {
    /// Create a new Mapper002 instance
    pub fn new(prg_rom: Vec<u8>, chr_rom: Vec<u8>, chr_ram_size: usize, mirroring: Mirroring) -> Self {
        let chr_is_ram = chr_rom.is_empty();
        let chr = if chr_is_ram {
            vec![0; chr_ram_size]
        } else {
            chr_rom
        };
        
        Mapper002 {
            prg_rom,
            chr,
            chr_is_ram,
            prg_bank: 0,
            mirroring,
        }
    }
}

impl Mapper for Mapper002 {
    fn read_prg(&self, addr: u16) -> u8 {
        match addr {
            0x8000..=0xBFFF => {
                // Switchable bank
                let bank_size = 16 * 1024;
                let bank_count = self.prg_rom.len() / bank_size;
                let bank = self.prg_bank % bank_count as u8;
                let offset = (addr & 0x3FFF) as usize;
                self.prg_rom[(bank as usize * bank_size) + offset]
            },
            0xC000..=0xFFFF => {
                // Fixed last bank
                let bank_size = 16 * 1024;
                let bank_count = self.prg_rom.len() / bank_size;
                let last_bank = bank_count - 1;
                let offset = (addr & 0x3FFF) as usize;
                self.prg_rom[(last_bank * bank_size) + offset]
            },
            _ => 0,
        }
    }
    
    fn write_prg(&mut self, addr: u16, data: u8) {
        if addr >= 0x8000 {
            // Bank select (ignore address, only data matters)
            self.prg_bank = data & 0x0F;
        }
    }
    
    fn read_chr(&self, addr: u16) -> u8 {
        self.chr[(addr & 0x1FFF) as usize]
    }
    
    fn write_chr(&mut self, addr: u16, data: u8) {
        if self.chr_is_ram {
            self.chr[(addr & 0x1FFF) as usize] = data;
        }
    }
    
    fn mirroring(&self) -> Mirroring {
        self.mirroring
    }
    
    fn irq_triggered(&self) -> bool {
        false
    }
    
    fn acknowledge_irq(&mut self) {
        // No IRQ in UxROM
    }
    
    fn notify_scanline(&mut self) {
        // No scanline counter in UxROM
    }
    
    fn reset(&mut self) {
        self.prg_bank = 0;
    }
}

impl CartridgeTrait for Mapper002 {
    fn load_ram(&mut self, _data: &[u8]) {
        // UxROM has no PRG RAM
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\mappers\mapper003.rs`:

```rs
//! Mapper 003 (CNROM) implementation
//!
//! This mapper features CHR ROM banking with fixed PRG ROM.
//! Used by games like Adventure Island, Paperboy, Defender II, etc.
//!
//! Memory map:
//! - PRG ROM: 16KB/32KB (fixed)
//! - CHR ROM: 8KB with banking

use crate::cartridge::{Mirroring, CartridgeTrait};
use super::Mapper;

pub struct Mapper003 {
    /// PRG ROM data
    prg_rom: Vec<u8>,
    
    /// CHR ROM/RAM data
    chr: Vec<u8>,
    
    /// Whether CHR is RAM (writable) or ROM (read-only)
    chr_is_ram: bool,
    
    /// Current CHR ROM bank
    chr_bank: u8,
    
    /// Mirroring mode
    mirroring: Mirroring,
}

impl Mapper003 {
    /// Create a new Mapper003 instance
    pub fn new(prg_rom: Vec<u8>, chr_rom: Vec<u8>, chr_ram_size: usize, mirroring: Mirroring) -> Self {
        let chr_is_ram = chr_rom.is_empty();
        let chr = if chr_is_ram {
            vec![0; chr_ram_size]
        } else {
            chr_rom
        };
        
        Mapper003 {
            prg_rom,
            chr,
            chr_is_ram,
            chr_bank: 0,
            mirroring,
        }
    }
}

impl Mapper for Mapper003 {
    fn read_prg(&self, addr: u16) -> u8 {
        let mask = if self.prg_rom.len() <= 16 * 1024 { 0x3FFF } else { 0x7FFF };
        self.prg_rom[(addr & mask) as usize]
    }
    
    fn write_prg(&mut self, addr: u16, data: u8) {
        if addr >= 0x8000 {
            // CHR bank select (ignore address, only data matters)
            self.chr_bank = data & 0x03;
        }
    }
    
    fn read_chr(&self, addr: u16) -> u8 {
        let bank_size = 8 * 1024;
        let bank_count = self.chr.len() / bank_size;
        if bank_count == 0 {
            return 0;
        }
        
        let bank = self.chr_bank % bank_count as u8;
        let offset = (addr & 0x1FFF) as usize;
        self.chr[(bank as usize * bank_size) + offset]
    }
    
    fn write_chr(&mut self, addr: u16, data: u8) {
        if self.chr_is_ram {
            let bank_size = 8 * 1024;
            let bank = self.chr_bank as usize;
            let offset = (addr & 0x1FFF) as usize;
            let chr_addr = (bank * bank_size) + offset;
            if chr_addr < self.chr.len() {
                self.chr[chr_addr] = data;
            }
        }
    }
    
    fn mirroring(&self) -> Mirroring {
        self.mirroring
    }
    
    fn irq_triggered(&self) -> bool {
        false
    }
    
    fn acknowledge_irq(&mut self) {
        // No IRQ in CNROM
    }
    
    fn notify_scanline(&mut self) {
        // No scanline counter in CNROM
    }
    
    fn reset(&mut self) {
        self.chr_bank = 0;
    }
}

impl CartridgeTrait for Mapper003 {
    fn load_ram(&mut self, _data: &[u8]) {
        // CNROM has no PRG RAM
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\mappers\mapper004.rs`:

```rs
//! Mapper 004 (MMC3) implementation
//!
//! This mapper features PRG ROM banking, CHR ROM banking, and configurable mirroring.
//! It also has an IRQ counter that can trigger on scanlines.
//!
//! Used by games like Super Mario Bros. 2/3, Mega Man 3-6, Kirby's Adventure, etc.
//!
//! Memory map:
//! - PRG ROM: Two switchable 8KB banks + one fixed 8KB bank + one switchable 8KB bank
//! - PRG RAM: 8KB (0x6000-0x7FFF)
//! - CHR ROM/RAM: Six switchable 1KB banks + two switchable 1KB banks

use crate::cartridge::{Mirroring, CartridgeTrait};
use super::Mapper;

pub struct Mapper004 {
    /// PRG ROM data
    prg_rom: Vec<u8>,
    
    /// CHR ROM/RAM data
    chr: Vec<u8>,
    
    /// PRG RAM data
    prg_ram: Vec<u8>,
    
    /// Whether CHR is RAM (writable) or ROM (read-only)
    chr_is_ram: bool,
    
    /// Current bank select (0-7)
    bank_select: u8,
    
    /// Current PRG ROM bank mode (0-1)
    prg_mode: u8,
    
    /// Current CHR ROM bank mode (0-1)
    chr_mode: u8,
    
    /// Bank registers (R0-R7)
    bank_registers: [u8; 8],
    
    /// Mirroring mode
    mirroring: Mirroring,
    
    /// IRQ counter
    irq_counter: u8,
    
    /// IRQ counter reload value
    irq_latch: u8,
    
    /// IRQ enabled flag
    irq_enabled: bool,
    
    /// IRQ pending flag
    irq_pending: bool,
    
    /// Reload flag (true = reload on next clock)
    irq_reload: bool,
    
    /// PRG RAM enable/protect
    prg_ram_protect: [bool; 2],
}

impl Mapper004 {
    /// Create a new Mapper004 instance
    pub fn new(prg_rom: Vec<u8>, chr_rom: Vec<u8>, prg_ram: Vec<u8>, mirroring: Mirroring) -> Self {
        let chr_is_ram = chr_rom.is_empty();
        let chr = if chr_is_ram {
            vec![0; 8 * 1024] // 8KB CHR RAM
        } else {
            chr_rom
        };
        
        Mapper004 {
            prg_rom,
            chr,
            prg_ram,
            chr_is_ram,
            bank_select: 0,
            prg_mode: 0,
            chr_mode: 0,
            bank_registers: [0; 8],
            mirroring,
            irq_counter: 0,
            irq_latch: 0,
            irq_enabled: false,
            irq_pending: false,
            irq_reload: false,
            prg_ram_protect: [false, false],
        }
    }
    
    /// Get the PRG ROM bank address for the specified bank number
    fn get_prg_bank_addr(&self, bank: usize) -> usize {
        let prg_bank_size = 8 * 1024;
        let prg_bank_count = self.prg_rom.len() / prg_bank_size;
        (bank % prg_bank_count) * prg_bank_size
    }
    
    /// Get the CHR ROM/RAM bank address for the specified bank number
    fn get_chr_bank_addr(&self, bank: usize) -> usize {
        let chr_bank_size = 1 * 1024;
        let chr_bank_count = self.chr.len() / chr_bank_size;
        (bank % chr_bank_count) * chr_bank_size
    }
    
    /// Map a CPU address to a PRG ROM address
    fn map_prg_addr(&self, addr: u16) -> usize {
        let bank_size = 8 * 1024;
        let prg_bank_count = self.prg_rom.len() / bank_size;
        let last_bank = prg_bank_count - 1;
        
        match addr {
            0x8000..=0x9FFF => {
                // Bank 0 (switchable or fixed to second-last bank)
                if self.prg_mode == 0 {
                    // R6 selects bank
                    let bank = self.bank_registers[6] as usize;
                    self.get_prg_bank_addr(bank) + (addr & 0x1FFF) as usize
                } else {
                    // Fixed to second-last bank
                    self.get_prg_bank_addr(last_bank - 1) + (addr & 0x1FFF) as usize
                }
            },
            0xA000..=0xBFFF => {
                // Bank 1 (always R7)
                let bank = self.bank_registers[7] as usize;
                self.get_prg_bank_addr(bank) + (addr & 0x1FFF) as usize
            },
            0xC000..=0xDFFF => {
                // Bank 2 (fixed to second-last bank or switchable)
                if self.prg_mode == 0 {
                    // Fixed to second-last bank
                    self.get_prg_bank_addr(last_bank - 1) + (addr & 0x1FFF) as usize
                } else {
                    // R6 selects bank
                    let bank = self.bank_registers[6] as usize;
                    self.get_prg_bank_addr(bank) + (addr & 0x1FFF) as usize
                }
            },
            0xE000..=0xFFFF => {
                // Bank 3 (fixed to last bank)
                self.get_prg_bank_addr(last_bank) + (addr & 0x1FFF) as usize
            },
            _ => 0,
        }
    }
    
    /// Map a PPU address to a CHR ROM/RAM address
    fn map_chr_addr(&self, addr: u16) -> usize {
        match addr {
            0x0000..=0x07FF => {
                // Bank 0 (R0 or R2)
                if self.chr_mode == 0 {
                    // R0 selects bank
                    let bank = self.bank_registers[0] as usize & 0xFE;
                    self.get_chr_bank_addr(bank) + (addr & 0x07FF) as usize
                } else {
                    // R2 selects bank
                    let bank = self.bank_registers[2] as usize;
                    self.get_chr_bank_addr(bank) + (addr & 0x03FF) as usize
                }
            },
            0x0800..=0x0FFF => {
                // Bank 1 (R0+1 or R3)
                if self.chr_mode == 0 {
                    // R0+1 selects bank
                    let bank = (self.bank_registers[0] as usize & 0xFE) + 1;
                    self.get_chr_bank_addr(bank) + (addr & 0x07FF) as usize
                } else {
                    // R3 selects bank
                    let bank = self.bank_registers[3] as usize;
                    self.get_chr_bank_addr(bank) + (addr & 0x03FF) as usize
                }
            },
            0x1000..=0x13FF => {
                // Bank 2 (R1 or R4)
                if self.chr_mode == 0 {
                    // R1 selects bank
                    let bank = self.bank_registers[1] as usize & 0xFE;
                    self.get_chr_bank_addr(bank) + (addr & 0x07FF) as usize
                } else {
                    // R4 selects bank
                    let bank = self.bank_registers[4] as usize;
                    self.get_chr_bank_addr(bank) + (addr & 0x03FF) as usize
                }
            },
            0x1400..=0x17FF => {
                // Bank 3 (R1+1 or R5)
                if self.chr_mode == 0 {
                    // R1+1 selects bank
                    let bank = (self.bank_registers[1] as usize & 0xFE) + 1;
                    self.get_chr_bank_addr(bank) + (addr & 0x07FF) as usize
                } else {
                    // R5 selects bank
                    let bank = self.bank_registers[5] as usize;
                    self.get_chr_bank_addr(bank) + (addr & 0x03FF) as usize
                }
            },
            0x1800..=0x1BFF => {
                // Bank 4 (R2 or R0)
                if self.chr_mode == 0 {
                    // R2 selects bank
                    let bank = self.bank_registers[2] as usize;
                    self.get_chr_bank_addr(bank) + (addr & 0x03FF) as usize
                } else {
                    // R0 selects bank
                    let bank = self.bank_registers[0] as usize & 0xFE;
                    self.get_chr_bank_addr(bank) + (addr & 0x07FF) as usize
                }
            },
            0x1C00..=0x1FFF => {
                // Bank 5 (R3 or R0+1)
                if self.chr_mode == 0 {
                    // R3 selects bank
                    let bank = self.bank_registers[3] as usize;
                    self.get_chr_bank_addr(bank) + (addr & 0x03FF) as usize
                } else {
                    // R0+1 selects bank
                    let bank = (self.bank_registers[0] as usize & 0xFE) + 1;
                    self.get_chr_bank_addr(bank) + (addr & 0x07FF) as usize
                }
            },
            _ => 0,
        }
    }
}

impl Mapper for Mapper004 {
    fn read_prg(&self, addr: u16) -> u8 {
        match addr {
            0x6000..=0x7FFF => {
                // PRG RAM
                if self.prg_ram_protect[0] {
                    let ram_addr = (addr & 0x1FFF) as usize;
                    if ram_addr < self.prg_ram.len() {
                        self.prg_ram[ram_addr]
                    } else {
                        0
                    }
                } else {
                    0
                }
            },
            0x8000..=0xFFFF => {
                // PRG ROM
                let rom_addr = self.map_prg_addr(addr);
                if rom_addr < self.prg_rom.len() {
                    self.prg_rom[rom_addr]
                } else {
                    0
                }
            },
            _ => 0,
        }
    }
    
    fn write_prg(&mut self, addr: u16, data: u8) {
        match addr {
            0x6000..=0x7FFF => {
                // PRG RAM
                if self.prg_ram_protect[0] && !self.prg_ram_protect[1] {
                    let ram_addr = (addr & 0x1FFF) as usize;
                    if ram_addr < self.prg_ram.len() {
                        self.prg_ram[ram_addr] = data;
                    }
                }
            },
            0x8000..=0x9FFF => {
                if addr & 0x01 == 0 {
                    // Bank select (even address)
                    self.bank_select = data & 0x07;
                    self.prg_mode = (data >> 6) & 0x01;
                    self.chr_mode = (data >> 7) & 0x01;
                } else {
                    // Bank data (odd address)
                    self.bank_registers[self.bank_select as usize] = data;
                }
            },
            0xA000..=0xBFFF => {
                if addr & 0x01 == 0 {
                    // Mirroring (even address)
                    self.mirroring = if (data & 0x01) == 0 {
                        Mirroring::Vertical
                    } else {
                        Mirroring::Horizontal
                    };
                } else {
                    // PRG RAM protect (odd address)
                    self.prg_ram_protect[0] = (data & 0x80) != 0;
                    self.prg_ram_protect[1] = (data & 0x40) != 0;
                }
            },
            0xC000..=0xDFFF => {
                if addr & 0x01 == 0 {
                    // IRQ latch (even address)
                    self.irq_latch = data;
                } else {
                    // IRQ reload (odd address)
                    self.irq_reload = true;
                }
            },
            0xE000..=0xFFFF => {
                if addr & 0x01 == 0 {
                    // IRQ disable (even address)
                    self.irq_enabled = false;
                    self.irq_pending = false;
                } else {
                    // IRQ enable (odd address)
                    self.irq_enabled = true;
                }
            },
            _ => {},
        }
    }
    
    fn read_chr(&self, addr: u16) -> u8 {
        let chr_addr = self.map_chr_addr(addr);
        if chr_addr < self.chr.len() {
            self.chr[chr_addr]
        } else {
            0
        }
    }
    
    fn write_chr(&mut self, addr: u16, data: u8) {
        if self.chr_is_ram {
            let chr_addr = self.map_chr_addr(addr);
            if chr_addr < self.chr.len() {
                self.chr[chr_addr] = data;
            }
        }
    }
    
    fn mirroring(&self) -> Mirroring {
        self.mirroring
    }
    
    fn irq_triggered(&self) -> bool {
        self.irq_pending
    }
    
    fn acknowledge_irq(&mut self) {
        self.irq_pending = false;
    }
    
    fn notify_scanline(&mut self) {
        // Clock IRQ counter on each scanline
        if self.irq_reload {
            self.irq_counter = self.irq_latch;
            self.irq_reload = false;
        } else if self.irq_counter == 0 {
            self.irq_counter = self.irq_latch;
        } else {
            self.irq_counter -= 1;
        }
        
        if self.irq_counter == 0 && self.irq_enabled {
            self.irq_pending = true;
        }
    }
    
    fn reset(&mut self) {
        self.bank_select = 0;
        self.prg_mode = 0;
        self.chr_mode = 0;
        self.bank_registers = [0; 8];
        self.irq_counter = 0;
        self.irq_latch = 0;
        self.irq_enabled = false;
        self.irq_pending = false;
        self.irq_reload = false;
        self.prg_ram_protect = [false, false];
    }
}

impl CartridgeTrait for Mapper004 {
    fn load_ram(&mut self, data: &[u8]) {
        if !data.is_empty() && data.len() <= self.prg_ram.len() {
            self.prg_ram[..data.len()].copy_from_slice(data);
        }
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\mappers\mod.rs`:

```rs
//! Mapper implementations for NES cartridges
//!
//! The NES uses various memory mappers to expand the capabilities of the hardware.
//! This module provides implementations for mappers 000-004, which cover a large
//! percentage of the NES game library.

mod mapper000; // NROM
mod mapper001; // MMC1
mod mapper002; // UxROM
mod mapper003; // CNROM
mod mapper004; // MMC3

pub use mapper000::Mapper000;
pub use mapper001::Mapper001;
pub use mapper002::Mapper002;
pub use mapper003::Mapper003;
pub use mapper004::Mapper004;

use crate::cartridge::{Mirroring, CartridgeTrait};

/// Trait for NES mappers
pub trait Mapper: CartridgeTrait {
    /// Read from PRG ROM/RAM
    fn read_prg(&self, addr: u16) -> u8;
    
    /// Write to PRG ROM/RAM
    fn write_prg(&mut self, addr: u16, value: u8);
    
    /// Read from CHR ROM/RAM
    fn read_chr(&self, addr: u16) -> u8;
    
    /// Write to CHR ROM/RAM
    fn write_chr(&mut self, addr: u16, value: u8);
    
    /// Get the current mirroring mode
    fn mirroring(&self) -> Mirroring;
    
    /// Check if an IRQ has been triggered
    fn irq_triggered(&self) -> bool {
        false
    }
    
    /// Acknowledge an IRQ
    fn acknowledge_irq(&mut self) {}
    
    /// Notify that a scanline has been completed
    fn notify_scanline(&mut self) {}

    /// Reset the mapper to its initial state
    fn reset(&mut self);
}

/// Create a new mapper instance based on mapper number
pub fn create_mapper(
    mapper_number: u8,
    prg_rom: Vec<u8>,
    chr_rom: Vec<u8>,
    prg_ram: Vec<u8>,
    chr_ram_size: usize,
    mirroring: Mirroring,
) -> Box<dyn Mapper> {
    match mapper_number {
        0 => Box::new(Mapper000::new(prg_rom, chr_rom, chr_ram_size, mirroring)),
        1 => Box::new(Mapper001::new(prg_rom, chr_rom, prg_ram, mirroring)),
        2 => Box::new(Mapper002::new(prg_rom, chr_rom, chr_ram_size, mirroring)),
        3 => Box::new(Mapper003::new(prg_rom, chr_rom, chr_ram_size, mirroring)),
        4 => Box::new(Mapper004::new(prg_rom, chr_rom, prg_ram, mirroring)),
        _ => panic!("Unsupported mapper: {}", mapper_number),
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\memory.rs`:

```rs
//! Memory bus implementation for the NES
//!
//! The NES has a 16-bit address space (0x0000 - 0xFFFF) with various memory-mapped
//! components. This module implements the memory bus that connects all components
//! and handles the memory mapping.
//!
//! Memory Map:
//! - 0x0000 - 0x07FF: 2KB internal RAM
//! - 0x0800 - 0x1FFF: Mirrors of internal RAM
//! - 0x2000 - 0x2007: PPU registers
//! - 0x2008 - 0x3FFF: Mirrors of PPU registers
//! - 0x4000 - 0x4017: APU and I/O registers
//! - 0x4018 - 0x401F: APU and I/O functionality that is normally disabled
//! - 0x4020 - 0xFFFF: Cartridge space (PRG ROM, PRG RAM, and mapper registers)

use std::cell::RefCell;
use std::rc::Rc;
use log::trace;

use crate::cartridge::{Cartridge, Mirroring};
use crate::ppu::PPU;

/// Size of the internal RAM (2KB)
const RAM_SIZE: usize = 0x0800;

/// Represents the memory bus connecting all NES components
pub struct MemoryBus {
    /// Internal RAM (2KB)
    ram: [u8; RAM_SIZE],
    
    /// Cartridge connected to the system
    cartridge: Option<Rc<RefCell<Cartridge>>>,
    
    /// PPU instance
    ppu: Rc<RefCell<PPU>>,
    
    /// PPU registers (shared with PPU)
    pub ppu_registers: [u8; 8],
    
    /// APU and I/O registers
    pub apu_io_registers: [u8; 0x18],
    
    /// OAM DMA is in progress
    pub oam_dma_active: bool,
    
    /// Current OAM DMA address
    pub oam_dma_addr: u8,
    
    /// Address for OAM DMA transfer
    pub oam_dma_page: u8,
    
    /// NMI signal is pending
    nmi_pending: bool,
    
    /// IRQ signal is pending
    irq_pending: bool,
}

impl MemoryBus {
    /// Create a new memory bus
    pub fn new(ppu: Rc<RefCell<PPU>>) -> Self {
        MemoryBus {
            ram: [0; RAM_SIZE],
            cartridge: None,
            ppu,
            ppu_registers: [0; 8],
            apu_io_registers: [0; 0x18],
            oam_dma_active: false,
            oam_dma_addr: 0,
            oam_dma_page: 0,
            nmi_pending: false,
            irq_pending: false,
        }
    }

    /// Reset the memory bus
    pub fn reset(&mut self) {
        self.ram = [0; RAM_SIZE];
        self.ppu_registers = [0; 8];
        self.apu_io_registers = [0; 0x18];
        self.oam_dma_active = false;
        self.oam_dma_addr = 0;
        self.oam_dma_page = 0;
        self.nmi_pending = false;
        self.irq_pending = false;
    }

    /// Insert a cartridge into the system
    pub fn insert_cartridge(&mut self, cartridge: Cartridge) {
        self.cartridge = Some(Rc::new(RefCell::new(cartridge)));
    }

    /// Remove the cartridge from the system
    pub fn remove_cartridge(&mut self) {
        self.cartridge = None;
    }

    // Updated read method to use the mapper system
    pub fn read(&mut self, addr: u16) -> u8 {
        match addr {
            // Internal RAM and mirrors
            0x0000..=0x1FFF => {
                let ram_addr = (addr & 0x07FF) as usize;
                self.ram[ram_addr]
            },
            
            // PPU registers and mirrors
            0x2000..=0x3FFF => {
                let reg_addr = ((addr - 0x2000) & 0x0007) as usize;
                self.read_ppu_register(reg_addr)
            },
            
            // APU and I/O registers
            0x4000..=0x4017 => {
                self.read_apu_io_register(addr)
            },
            
            // APU and I/O functionality (normally disabled)
            0x4018..=0x401F => {
                trace!("Read from disabled APU and I/O functionality: ${:04X}", addr);
                0
            },
            
            // Cartridge space
            0x4020..=0xFFFF => {
                if let Some(cart) = &self.cartridge {
                    cart.borrow().read(addr)
                } else {
                    trace!("Read from cartridge space with no cartridge: ${:04X}", addr);
                    0
                }
            },
        }
    }

    // Updated write method to use the mapper system
    pub fn write(&mut self, addr: u16, value: u8) {
        match addr {
            // Internal RAM and mirrors
            0x0000..=0x1FFF => {
                let ram_addr = (addr & 0x07FF) as usize;
                self.ram[ram_addr] = value;
            },
            
            // PPU registers and mirrors
            0x2000..=0x3FFF => {
                let reg_addr = ((addr - 0x2000) & 0x0007) as usize;
                self.write_ppu_register(reg_addr, value);
            },
            
            // APU and I/O registers
            0x4000..=0x4017 => {
                self.write_apu_io_register(addr, value);
            },
            
            // APU and I/O functionality (normally disabled)
            0x4018..=0x401F => {
                trace!("Write to disabled APU and I/O functionality: ${:04X} = ${:02X}", addr, value);
            },
            
            // Cartridge space
            0x4020..=0xFFFF => {
                if let Some(cart) = &self.cartridge {
                    cart.borrow_mut().write(addr, value);
                } else {
                    trace!("Write to cartridge space with no cartridge: ${:04X} = ${:02X}", addr, value);
                }
            },
        }
    }

    /// Read from a PPU register
    fn read_ppu_register(&mut self, reg: usize) -> u8 {
        match reg {
            // PPUSTATUS ($2002)
            2 => {
                // Reading PPUSTATUS clears bit 7 (vblank) and resets the PPU address latch
                let value = self.ppu_registers[2];
                self.ppu_registers[2] &= 0x7F; // Clear VBlank flag
                self.ppu.borrow_mut().w = false; // Reset write toggle
                value
            },
            
            // OAMDATA ($2004)
            4 => {
                // Reading from OAMDATA during OAM DMA should return 0xFF
                if self.oam_dma_active {
                    0xFF
                } else {
                    self.ppu.borrow_mut().oam[self.ppu_registers[3] as usize]
                }
            },
            
            // PPUDATA ($2007)
            7 => {
                // Get current address and buffer value
                let addr;
                let result;
                {
                    let ppu = self.ppu.borrow();
                    addr = ppu.v;
                    result = ppu.data_buffer;
                }
                
                // Update VRAM address
                {
                    let mut ppu = self.ppu.borrow_mut();
                    ppu.v = ppu.v.wrapping_add(if (self.ppu_registers[0] & 0x04) != 0 { 32 } else { 1 });
                }
                
                // Handle the read based on address
                let value = if addr >= 0x3F00 {
                    // Palette reads are immediate
                    let palette_addr = (addr & 0x1F) as usize;
                    self.ppu.borrow().palette_ram[palette_addr]
                } else if addr < 0x2000 {
                    // Pattern tables (CHR ROM/RAM)
                    if let Some(cart) = &self.cartridge {
                        cart.borrow().read_chr(addr)
                    } else {
                        0
                    }
                } else if addr < 0x3000 {
                    // Nametables
                    let mirrored_addr = self.mirror_vram_addr(addr);
                    self.ppu.borrow().vram[mirrored_addr as usize]
                } else {
                    // Mirrors of nametables
                    let mirrored_addr = self.mirror_vram_addr(addr - 0x1000);
                    self.ppu.borrow().vram[mirrored_addr as usize]
                };
                
                // Update data buffer
                if addr < 0x3F00 {
                    // For non-palette reads, return the buffer and update it
                    {
                        let mut ppu = self.ppu.borrow_mut();
                        ppu.data_buffer = value;
                    }
                    result
                } else {
                    // For palette reads, return the value immediately
                    {
                        let mut ppu = self.ppu.borrow_mut();
                        ppu.data_buffer = value;
                    }
                    value
                }
            },
            
            // Other PPU registers
            _ => self.ppu_registers[reg],
        }
    }

    /// Write to a PPU register
    fn write_ppu_register(&mut self, reg: usize, value: u8) {
        match reg {
            // PPUCTRL ($2000)
            0 => {
                let nmi_change = (self.ppu_registers[0] ^ value) & 0x80;
                self.ppu_registers[0] = value;
                
                {
                    let mut ppu = self.ppu.borrow_mut();
                    ppu.t = (ppu.t & 0xF3FF) | ((value as u16 & 0x03) << 10);
                }
                
                // If NMI enable changes from 0 to 1 during VBlank, trigger NMI
                if nmi_change != 0 && (value & 0x80) != 0 && (self.ppu_registers[2] & 0x80) != 0 {
                    self.nmi_pending = true;
                }
            },
            
            // PPUMASK ($2001)
            1 => {
                self.ppu_registers[1] = value;
            },
            
            // PPUSTATUS ($2002)
            2 => {
                // PPUSTATUS is read-only
                trace!("Attempted write to read-only PPUSTATUS: ${:02X}", value);
            },
            
            // OAMADDR ($2003)
            3 => {
                self.ppu_registers[3] = value;
            },
            
            // OAMDATA ($2004)
            4 => {
                let oam_addr = self.ppu_registers[3] as usize;
                {
                    let mut ppu = self.ppu.borrow_mut();
                    ppu.oam[oam_addr] = value;
                }
                self.ppu_registers[3] = self.ppu_registers[3].wrapping_add(1);
            },
            
            // PPUSCROLL ($2005)
            5 => {
                let ppu_w = self.ppu.borrow().w;
                if !ppu_w {
                    // First write (X scroll)
                    {
                        let mut ppu = self.ppu.borrow_mut();
                        ppu.t = (ppu.t & 0xFFE0) | ((value as u16) >> 3);
                        ppu.x = value & 0x07;
                        ppu.w = true;
                    }
                } else {
                    // Second write (Y scroll)
                    {
                        let mut ppu = self.ppu.borrow_mut();
                        ppu.t = (ppu.t & 0x8FFF) | ((value as u16 & 0x07) << 12);
                        ppu.t = (ppu.t & 0xFC1F) | ((value as u16 & 0xF8) << 2);
                        ppu.w = false;
                    }
                }
            },
            
            // PPUADDR ($2006)
            6 => {
                let ppu_w = self.ppu.borrow().w;
                if !ppu_w {
                    // First write (high byte)
                    {
                        let mut ppu = self.ppu.borrow_mut();
                        ppu.t = (ppu.t & 0x00FF) | ((value as u16 & 0x3F) << 8);
                        ppu.w = true;
                    }
                } else {
                    // Second write (low byte)
                    {
                        let mut ppu = self.ppu.borrow_mut();
                        ppu.t = (ppu.t & 0xFF00) | value as u16;
                        ppu.v = ppu.t;
                        ppu.w = false;
                    }
                }
            },
            
            // PPUDATA ($2007)
            7 => {
                let addr;
                {
                    let ppu = self.ppu.borrow();
                    addr = ppu.v;
                }
                
                let increment = if (self.ppu_registers[0] & 0x04) != 0 { 32 } else { 1 };
                
                // Write to appropriate memory
                if addr >= 0x3F00 {
                    // Palette RAM
                    let palette_addr = (addr & 0x1F) as usize;
                    self.ppu.borrow_mut().palette_ram[palette_addr] = value;
                } else if addr < 0x2000 {
                    // Pattern tables (CHR ROM/RAM)
                    if let Some(cart) = &self.cartridge {
                        cart.borrow_mut().write_chr(addr, value);
                    }
                } else if addr < 0x3000 {
                    // Nametables
                    let mirrored_addr = self.mirror_vram_addr(addr);
                    self.ppu.borrow_mut().vram[mirrored_addr as usize] = value;
                } else {
                    // Mirrors of nametables
                    let mirrored_addr = self.mirror_vram_addr(addr - 0x1000);
                    self.ppu.borrow_mut().vram[mirrored_addr as usize] = value;
                }
                
                // Update VRAM address after write
                {
                    let mut ppu = self.ppu.borrow_mut();
                    ppu.v = ppu.v.wrapping_add(increment);
                }
            },
            
            _ => {}
        }
    }

    /// Mirror VRAM address based on current mirroring mode
    fn mirror_vram_addr(&self, addr: u16) -> u16 {
        let addr = addr & 0x2FFF;
        let mirroring = if let Some(cart) = &self.cartridge {
            cart.borrow().get_mirroring()
        } else {
            Mirroring::Horizontal
        };
        
        match mirroring {
            Mirroring::Horizontal => {
                // Nametable layout:
                // A A
                // B B
                let table = (addr >> 11) & 0x01;
                (table << 10) | (addr & 0x03FF)
            },
            Mirroring::Vertical => {
                // Nametable layout:
                // A B
                // A B
                let table = (addr >> 10) & 0x01;
                (table << 10) | (addr & 0x03FF)
            },
            Mirroring::SingleScreenLower => {
                // Single screen, lower bank
                addr & 0x03FF
            },
            Mirroring::SingleScreenUpper => {
                // Single screen, upper bank
                0x0400 | (addr & 0x03FF)
            },
            Mirroring::FourScreen => {
                // Four screen - no mirroring
                addr & 0x0FFF
            },
        }
    }

    /// Read from an APU or I/O register
    fn read_apu_io_register(&mut self, addr: u16) -> u8 {
        match addr {
            // Controller 1 ($4016)
            0x4016 => {
                // Controller 1 read handled in controller module
                self.apu_io_registers[0x16]
            },
            
            // Controller 2 ($4017)
            0x4017 => {
                // Controller 2 read handled in controller module
                self.apu_io_registers[0x17]
            },
            
            // Other APU and I/O registers
            _ => {
                let reg = (addr - 0x4000) as usize;
                self.apu_io_registers[reg]
            }
        }
    }

    /// Write to an APU or I/O register
    fn write_apu_io_register(&mut self, addr: u16, value: u8) {
        match addr {
            // OAM DMA ($4014)
            0x4014 => {
                self.oam_dma_page = value;
                self.oam_dma_active = true;
                self.oam_dma_addr = 0;
                // OAM DMA will be performed in the NES main loop
            },
            
            // Controller 1 ($4016)
            0x4016 => {
                // Controller strobe handling
                self.apu_io_registers[0x16] = value;
            },
            
            // Controller 2 and APU frame counter ($4017)
            0x4017 => {
                // APU frame counter and controller 2 handling
                self.apu_io_registers[0x17] = value;
            },
            
            // Other APU and I/O registers
            _ => {
                let reg = (addr - 0x4000) as usize;
                self.apu_io_registers[reg] = value;
            }
        }
    }

    /// Check if an NMI signal is pending and clear it
    pub fn peek_nmi(&self) -> bool {
        self.nmi_pending
    }

    /// Acknowledge and clear the NMI signal
    pub fn acknowledge_nmi(&mut self) {
        self.nmi_pending = false;
    }

    /// Check if an IRQ signal is pending
    pub fn peek_irq(&self) -> bool {
        self.irq_pending
    }

    /// Acknowledge and clear the IRQ signal
    pub fn acknowledge_irq(&mut self) {
        self.irq_pending = false;
    }

    /// Set the IRQ signal from the cartridge
    pub fn set_irq_from_cartridge(&mut self, value: bool) {
        self.irq_pending = value;
    }

    /// Perform OAM DMA transfer
    pub fn perform_oam_dma(&mut self) -> u32 {
        if !self.oam_dma_active {
            return 0;
        }
        
        // OAM DMA takes 513 or 514 CPU cycles (depending on whether it starts on an odd or even cycle)
        // We'll assume 514 for simplicity
        let dma_source_base = (self.oam_dma_page as u16) << 8;
        
        for i in 0..256 {
            let source_addr = dma_source_base + i;
            let value = self.read(source_addr);
            
            // Write to OAM through OAMDATA ($2004)
            self.write(0x2004, value);
        }
        
        self.oam_dma_active = false;
        
        // Return the number of cycles consumed
        514
    }

    /// Get a reference to the RAM
    pub fn get_ram(&self) -> &[u8] {
        &self.ram
    }

    /// Get a mutable reference to the RAM
    pub fn get_ram_mut(&mut self) -> &mut [u8] {
        &mut self.ram
    }

    /// Copy data into RAM
    pub fn copy_ram(&mut self, data: &[u8]) {
        if data.len() == self.ram.len() {
            self.ram.copy_from_slice(data);
        }
    }

    /// Get the current cartridge
    pub fn get_cartridge(&self) -> Option<Rc<RefCell<Cartridge>>> {
        self.cartridge.clone()
    }

    pub fn get_nmi_pending(&self) -> bool {
        self.nmi_pending
    }

    pub fn get_irq_pending(&self) -> bool {
        self.irq_pending
    }

    pub fn set_nmi_pending(&mut self, value: bool) {
        self.nmi_pending = value;
    }

    pub fn set_irq_pending(&mut self, value: bool) {
        self.irq_pending = value;
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\nes.rs`:

```rs
//! NES system implementation
//!
//! This module implements the core NES system, tying together the CPU, PPU, APU,
//! memory management, and input handling.

use anyhow::{Context, Result};
use log::info;
use sdl2::{
    event::Event,
    pixels::PixelFormatEnum,
    render::TextureCreator,
    video::WindowContext,
    keyboard::Keycode,
};
use std::path::Path;
use std::time::{Duration, Instant};
use std::rc::Rc;
use std::cell::RefCell;

use crate::{
    apu::APU,
    audio::AudioSystem,
    cartridge::{Cartridge, ROMParseError},
    cpu::CPU,
    memory::MemoryBus,
    ppu::{PPU, TVSystem},
    controller::Controller,
};

/// NES screen width in pixels
pub const SCREEN_WIDTH: u32 = 256;
/// NES screen height in pixels
pub const SCREEN_HEIGHT: u32 = 240;
/// Default scale factor for the display window
const SCALE_FACTOR: u32 = 3;

/// Represents the NES hardware system
pub struct NES {
    /// CPU
    pub cpu: CPU,
    
    /// PPU
    pub ppu: Rc<RefCell<PPU>>,
    
    /// APU
    pub apu: APU,
    
    /// Memory bus
    pub memory_bus: MemoryBus,
    
    /// Controller 1
    pub controller1: Controller,
    
    /// Controller 2
    pub controller2: Controller,
    
    /// Audio system
    pub audio_system: AudioSystem,
    
    /// Running state
    pub running: bool,
    
    /// Paused state
    pub paused: bool,
    
    /// Current frame count
    pub frame_count: u64,
    
    /// Frame timing
    pub frame_time: Duration,
    
    /// TV system (NTSC/PAL)
    pub tv_system: TVSystem,
    
    /// Last frame time
    last_frame_time: Instant,
    
    /// Frames per second
    pub fps: f64,
}

impl NES {
    /// Create a new NES system
    pub fn new(tv_system: TVSystem) -> Self {
        let ppu = Rc::new(RefCell::new(PPU::new(tv_system)));
        let memory_bus = MemoryBus::new(Rc::clone(&ppu));
        
        Self {
            cpu: CPU::new(),
            ppu: Rc::clone(&ppu),
            apu: APU::new(),
            memory_bus,
            controller1: Controller::new(),
            controller2: Controller::new(),
            audio_system: AudioSystem::new(44100), // Standard CD quality sample rate
            running: false,
            paused: false,
            frame_count: 0,
            frame_time: Duration::from_secs(0),
            tv_system,
            last_frame_time: Instant::now(),
            fps: 0.0,
        }
    }

    /// Load an NES cartridge from ROM data
    pub fn load_cartridge(&mut self, rom_data: &[u8]) -> Result<(), ROMParseError> {
        let cartridge = Cartridge::from_bytes(rom_data)?;
        self.memory_bus.insert_cartridge(cartridge);
        self.reset();
        
        info!("Cartridge loaded successfully");
        Ok(())
    }

    /// Load an NES cartridge from a file
    pub fn load_cartridge_from_file<P: AsRef<Path>>(&mut self, path: P) -> Result<()> {
        let rom_data = std::fs::read(&path)
            .with_context(|| format!("Failed to read ROM file: {}", path.as_ref().display()))?;
        
        self.load_cartridge(&rom_data)
            .with_context(|| format!("Failed to load ROM: {}", path.as_ref().display()))?;
        
        Ok(())
    }

    /// Reset the NES system to its initial state
    pub fn reset(&mut self) {
        self.cpu.reset();
        self.ppu.borrow_mut().reset();
        self.apu.reset();
        self.memory_bus.reset();
        self.controller1.reset();
        self.controller2.reset();
        self.frame_count = 0;
        self.running = false;
        self.paused = false;

        // Initialize PPU registers
        self.memory_bus.ppu_registers[0] = 0x00; // PPUCTRL - disable NMI initially
        self.memory_bus.ppu_registers[1] = 0x00; // PPUMASK - disable rendering initially
        
        // Run enough cycles to warm up the PPU (2 frames worth)
        let cycles_per_frame = match self.tv_system {
            TVSystem::NTSC => 29780,
            TVSystem::PAL => 33247,
            TVSystem::Dendy => 33247,
        };

        for _ in 0..2 {
            let mut cycles = cycles_per_frame;
            while cycles > 0 {
                let cpu_cycles = self.cpu.step(&mut self.memory_bus);
                cycles -= cpu_cycles;
                
                // PPU runs at 3x CPU rate
                for _ in 0..cpu_cycles * 3 {
                    self.ppu.borrow_mut().step(&mut self.memory_bus);
                }
            }
        }
        
        // Enable rendering
        self.memory_bus.ppu_registers[0] = 0x90; // PPUCTRL - enable NMI, background pattern table at 0x1000
        self.memory_bus.ppu_registers[1] = 0x1E; // PPUMASK - show background and sprites
    }

    /// Run the emulator
    pub fn run(&mut self) -> Result<()> {
        // Initialize SDL2
        let sdl_context = sdl2::init()
            .map_err(|e| anyhow::anyhow!("Failed to initialize SDL2: {}", e))?;
        
        let video_subsystem = sdl_context.video()
            .map_err(|e| anyhow::anyhow!("Failed to initialize SDL2 video subsystem: {}", e))?;
        
        let window = video_subsystem
            .window(
                "RustyNES",
                SCREEN_WIDTH * SCALE_FACTOR,
                SCREEN_HEIGHT * SCALE_FACTOR,
            )
            .position_centered()
            .build()
            .map_err(|e| anyhow::anyhow!("Failed to create window: {}", e))?;
        
        let mut canvas = window
            .into_canvas()
            .accelerated()
            .present_vsync()
            .build()
            .map_err(|e| anyhow::anyhow!("Failed to create canvas: {}", e))?;
        
        let texture_creator: TextureCreator<WindowContext> = canvas.texture_creator();
        let mut texture = texture_creator
            .create_texture_streaming(
                PixelFormatEnum::RGB24,
                SCREEN_WIDTH,
                SCREEN_HEIGHT,
            )
            .with_context(|| "Failed to create texture")?;
        
        canvas.set_scale(SCALE_FACTOR as f32, SCALE_FACTOR as f32)
            .map_err(|e| anyhow::anyhow!("Failed to set canvas scale: {}", e))?;
        
        let mut event_pump = sdl_context.event_pump()
            .map_err(|e| anyhow::anyhow!("Failed to get event pump: {}", e))?;

        // Start the emulator
        self.running = true;
        
        // Frame timing
        let target_frame_time = match self.tv_system {
            TVSystem::NTSC => Duration::from_nanos(16_666_667), // 60Hz
            TVSystem::PAL => Duration::from_nanos(20_000_000),  // 50Hz
            TVSystem::Dendy => Duration::from_nanos(20_000_000), // 50Hz
        };
        
        // Main emulation loop
        while self.running {
            // Handle events
            for event in event_pump.poll_iter() {
                match event {
                    Event::Quit { .. } => {
                        self.running = false;
                    },
                    Event::KeyDown { keycode: Some(keycode), .. } => {
                        self.handle_key_down(keycode);
                    },
                    Event::KeyUp { keycode: Some(keycode), .. } => {
                        self.handle_key_up(keycode);
                    },
                    _ => {}
                }
            }

            // Skip processing if paused
            if !self.paused {
                // Run one frame of emulation
                self.run_frame()?;
                
                // Update the screen
                texture.update(None, &self.ppu.borrow().get_frame_buffer(), SCREEN_WIDTH as usize * 3)
                    .with_context(|| "Failed to update texture")?;
                
                // Process audio
                self.audio_system.process(&mut self.apu);
                
                // Calculate FPS
                let now = Instant::now();
                let frame_duration = now.duration_since(self.last_frame_time);
                self.fps = 1.0 / frame_duration.as_secs_f64();
                self.last_frame_time = now;
                
                // Frame timing
                if frame_duration < target_frame_time {
                    std::thread::sleep(target_frame_time - frame_duration);
                }
                
                self.frame_count += 1;
            }
            
            // Render
            canvas.clear();
            canvas.copy(&texture, None, None)
                .map_err(|e| anyhow::anyhow!("Failed to copy texture to canvas: {}", e))?;
            canvas.present();
        }
        
        // Cleanup audio
        self.audio_system.close();

        Ok(())
    }

    /// Run a single frame of emulation
    pub fn run_frame(&mut self) -> Result<()> {
        // A frame consists of a specific number of cycles
        // For NTSC NES: 29780 CPU cycles per frame (PPU runs at 3x CPU rate)
        // For PAL NES: 33247 CPU cycles per frame
        let cycles_per_frame = match self.tv_system {
            TVSystem::NTSC => 29780,
            TVSystem::PAL => 33247,
            TVSystem::Dendy => 33247,
        };

        let mut cycles_remaining = cycles_per_frame;
        while cycles_remaining > 0 {
            // Run one CPU cycle
            let cpu_cycles = self.cpu.step(&mut self.memory_bus);
            cycles_remaining -= cpu_cycles;

            // PPU runs at 3x CPU rate
            for _ in 0..cpu_cycles * 3 {
                self.ppu.borrow_mut().step(&mut self.memory_bus);
            }

            // Run APU
            self.apu.step(&mut self.memory_bus);
        }

        Ok(())
    }

    /// Handle key down events
    fn handle_key_down(&mut self, keycode: Keycode) {
        match keycode {
            Keycode::Escape => self.running = false,
            Keycode::P => self.paused = !self.paused,
            Keycode::A => self.controller1.set_button_pressed(Controller::BUTTON_A, true),  // A button
            Keycode::S => self.controller1.set_button_pressed(Controller::BUTTON_B, true),  // B button
            Keycode::Return => self.controller1.set_button_pressed(Controller::BUTTON_START, true),  // Start
            Keycode::Space => self.controller1.set_button_pressed(Controller::BUTTON_SELECT, true),  // Select
            Keycode::Left => self.controller1.set_button_pressed(Controller::BUTTON_LEFT, true),   // Left
            Keycode::Right => self.controller1.set_button_pressed(Controller::BUTTON_RIGHT, true),  // Right
            Keycode::Up => self.controller1.set_button_pressed(Controller::BUTTON_UP, true),     // Up
            Keycode::Down => self.controller1.set_button_pressed(Controller::BUTTON_DOWN, true),   // Down
            _ => {}
        }
    }

    /// Handle key up events
    fn handle_key_up(&mut self, keycode: Keycode) {
        match keycode {
            Keycode::A => self.controller1.set_button_pressed(Controller::BUTTON_A, false),  // A button
            Keycode::S => self.controller1.set_button_pressed(Controller::BUTTON_B, false),  // B button
            Keycode::Return => self.controller1.set_button_pressed(Controller::BUTTON_START, false),  // Start
            Keycode::Space => self.controller1.set_button_pressed(Controller::BUTTON_SELECT, false),  // Select
            Keycode::Left => self.controller1.set_button_pressed(Controller::BUTTON_LEFT, false),   // Left
            Keycode::Right => self.controller1.set_button_pressed(Controller::BUTTON_RIGHT, false),  // Right
            Keycode::Up => self.controller1.set_button_pressed(Controller::BUTTON_UP, false),     // Up
            Keycode::Down => self.controller1.set_button_pressed(Controller::BUTTON_DOWN, false),   // Down
            _ => {}
        }
    }
}

```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\ppu\background.rs`:

```rs
//! Background rendering for the PPU
//!
//! This module handles rendering the background tiles for the NES.
//! The background is composed of 8x8 pixel tiles arranged in a 32x30 grid (nametable).

use crate::memory::MemoryBus;

#[derive(Clone)]
/// Background rendering state
pub struct Background {
    /// Tile shifter for pattern table low bits
    pub shifter_pattern_lo: u16,
    
    /// Tile shifter for pattern table high bits
    pub shifter_pattern_hi: u16,
    
    /// Attribute table shifter for palette low bits
    pub shifter_attr_lo: u16,
    
    /// Attribute table shifter for palette high bits
    pub shifter_attr_hi: u16,
    
    /// Next tile ID from nametable
    pub next_tile_id: u8,
    
    /// Next tile attribute from attribute table
    pub next_tile_attr: u8,
    
    /// Next tile pattern low byte
    pub next_pattern_lo: u8,
    
    /// Next tile pattern high byte
    pub next_pattern_hi: u8,
}

impl Background {
    /// Create a new background rendering state
    pub fn new() -> Self {
        Background {
            shifter_pattern_lo: 0,
            shifter_pattern_hi: 0,
            shifter_attr_lo: 0,
            shifter_attr_hi: 0,
            next_tile_id: 0,
            next_tile_attr: 0,
            next_pattern_lo: 0,
            next_pattern_hi: 0,
        }
    }
    
    /// Reset the background rendering state
    pub fn reset(&mut self) {
        self.shifter_pattern_lo = 0;
        self.shifter_pattern_hi = 0;
        self.shifter_attr_lo = 0;
        self.shifter_attr_hi = 0;
        self.next_tile_id = 0;
        self.next_tile_attr = 0;
        self.next_pattern_lo = 0;
        self.next_pattern_hi = 0;
    }
    
    /// Update the background shifters
    pub fn update_shifters(&mut self) {
        // Shift the pattern and attribute shifters
        self.shifter_pattern_lo <<= 1;
        self.shifter_pattern_hi <<= 1;
        self.shifter_attr_lo <<= 1;
        self.shifter_attr_hi <<= 1;
    }
    
    /// Load the background shifters with new tile data
    pub fn load_shifters(&mut self) {
        // Load new data into the shifters
        self.shifter_pattern_lo &= 0xFF00;
        self.shifter_pattern_lo |= self.next_pattern_lo as u16;
        
        self.shifter_pattern_hi &= 0xFF00;
        self.shifter_pattern_hi |= self.next_pattern_hi as u16;
        
        // Set attribute shifters based on palette bits
        self.shifter_attr_lo &= 0xFF00;
        self.shifter_attr_lo |= if (self.next_tile_attr & 0x01) != 0 {
            0xFF
        } else {
            0x00
        };
        
        self.shifter_attr_hi &= 0xFF00;
        self.shifter_attr_hi |= if (self.next_tile_attr & 0x02) != 0 {
            0xFF
        } else {
            0x00
        };
    }
    
    /// Fetch tile data for the background
    pub fn fetch_tile_data(&mut self, v: u16, cycle: u16, rendering_enabled: bool, bus: &mut MemoryBus) {
        if !rendering_enabled {
            return;
        }

        match cycle % 8 {
            1 => {
                // Nametable byte
                let addr = 0x2000 | (v & 0x0FFF);
                self.next_tile_id = bus.read(addr);
            },
            3 => {
                // Attribute table byte
                let addr = 0x23C0 | (v & 0x0C00) | ((v >> 4) & 0x38) | ((v >> 2) & 0x07);
                let attr = bus.read(addr);
                
                // Determine which quadrant of the attribute byte to use
                let shift = ((v >> 4) & 0x04) | (v & 0x02);
                self.next_tile_attr = (attr >> shift) & 0x03;
                
                // Update shifters
                self.update_shifters();
            },
            5 => {
                // Pattern table low byte
                let pattern_addr = ((bus.ppu_registers[0] & 0x10) as u16) << 8 | (self.next_tile_id as u16 * 16) | ((v >> 12) & 0x07) as u16;
                self.next_pattern_lo = bus.read(pattern_addr);
                
                // Update shifters
                self.update_shifters();
            },
            7 => {
                // Pattern table high byte
                let pattern_addr = ((bus.ppu_registers[0] & 0x10) as u16) << 8 | (self.next_tile_id as u16 * 16) | ((v >> 12) & 0x07) as u16 | 0x08;
                self.next_pattern_hi = bus.read(pattern_addr);
                
                // Update shifters
                self.update_shifters();
            },
            0 => {
                // Load the new data into the shifters
                self.load_shifters();
            },
            _ => {}
        }
    }
    
    /// Get the background pixel at the current position
    pub fn get_pixel(&self, _v: u16, x: u8) -> (u8, u8) {
        // Get the pixel value from the shifters
        let mux = 0x8000 >> x;
        
        let pixel_lo = if (self.shifter_pattern_lo & mux) != 0 { 1 } else { 0 };
        let pixel_hi = if (self.shifter_pattern_hi & mux) != 0 { 2 } else { 0 };
        let pixel_val = pixel_hi | pixel_lo;
        
        let palette_lo = if (self.shifter_attr_lo & mux) != 0 { 1 } else { 0 };
        let palette_hi = if (self.shifter_attr_hi & mux) != 0 { 2 } else { 0 };
        let palette = palette_hi | palette_lo;
        
        (palette, pixel_val)
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\ppu\mod.rs`:

```rs
//! PPU (Picture Processing Unit) implementation
//!
//! The PPU is responsible for generating the video signal for the NES. It renders
//! the background and sprites, and handles various aspects of the NES graphics system.
//!
//! This implementation focuses on cycle-accurate timing and correct rendering.

mod background;
mod palette;
mod sprites;

use std::cell::RefCell;
use std::rc::Rc;
use serde::{Serialize, Deserialize};

use crate::memory::MemoryBus;
use crate::cartridge::Mirroring;

pub use background::*;
pub use palette::*;
pub use sprites::*;

/// PPU screen width in pixels
pub const SCREEN_WIDTH: u32 = 256;

/// PPU screen height in pixels
pub const SCREEN_HEIGHT: u32 = 240;

/// Total PPU scanlines per frame
pub const SCANLINES_PER_FRAME: u16 = 262;

/// Last visible scanline
pub const LAST_VISIBLE_SCANLINE: u16 = 239;

/// Pre-render scanline
pub const PRE_RENDER_SCANLINE: u16 = 261;

/// Visible cycles per scanline
pub const VISIBLE_CYCLES_PER_SCANLINE: u16 = 256;

/// Total cycles per scanline
pub const CYCLES_PER_SCANLINE: u16 = 341;

/// TV system types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TVSystem {
    /// NTSC (North America, Japan, etc.)
    NTSC,
    
    /// PAL (Europe, Australia, etc.)
    PAL,
    
    /// Dendy (Russian NES clone)
    Dendy,
}

/// Represents the NES PPU (Picture Processing Unit)
#[derive(Clone)]
pub struct PPU {
    /// Current cycle within the scanline (0-340)
    pub cycle: u16,
    
    /// Current scanline (0-261 for NTSC, 0-311 for PAL)
    pub scanline: u16,
    
    /// Current frame count
    pub frame: u64,
    
    /// PPU internal VRAM address (current)
    pub v: u16,
    
    /// PPU internal VRAM address (temporary)
    pub t: u16,
    
    /// Fine X scroll (3 bits)
    pub x: u8,
    
    /// First or second write toggle
    pub w: bool,
    
    /// NMI occurred flag
    pub nmi_occurred: bool,
    
    /// NMI output flag
    pub nmi_output: bool,
    
    /// Even or odd frame
    pub even_frame: bool,
    
    /// PPU internal data buffer
    pub data_buffer: u8,
    
    /// VBlank suppression flag
    pub suppress_vblank: bool,
    
    /// OAM (Object Attribute Memory) - 256 bytes for sprite data
    pub oam: [u8; 256],
    
    /// Secondary OAM - 32 bytes for sprite data for the current scanline
    pub secondary_oam: [u8; 32],
    
    /// PPU internal VRAM - 2KB
    pub vram: [u8; 2048],
    
    /// Palette RAM - 32 bytes
    pub palette_ram: [u8; 32],
    
    /// Frame buffer (RGB24 format)
    pub frame_buffer: Vec<u8>,
    
    /// Background rendering state
    pub bg: Background,
    
    /// Sprite rendering state
    pub sprites: Sprites,
    
    /// TV system
    pub tv_system: TVSystem,
    
    /// Current palette (there are several available palettes)
    pub palette_table: Rc<RefCell<PaletteTable>>,
}

impl PPU {
    /// Create a new PPU instance
    pub fn new(tv_system: TVSystem) -> Self {
        PPU {
            cycle: 0,
            scanline: 0,
            frame: 0,
            v: 0,
            t: 0,
            x: 0,
            w: false,
            nmi_occurred: false,
            nmi_output: false,
            even_frame: true,
            data_buffer: 0,
            suppress_vblank: false,
            oam: [0; 256],
            secondary_oam: [0; 32],
            vram: [0; 2048],
            palette_ram: [0; 32],
            frame_buffer: vec![0; (SCREEN_WIDTH * SCREEN_HEIGHT * 3) as usize],
            bg: Background::new(),
            sprites: Sprites::new(),
            tv_system,
            palette_table: Rc::new(RefCell::new(PaletteTable::new_ntsc())),
        }
    }

    /// Reset the PPU
    pub fn reset(&mut self) {
        self.cycle = 0;
        self.scanline = 0;
        self.frame = 0;
        self.v = 0;
        self.t = 0;
        self.x = 0;
        self.w = false;
        self.nmi_occurred = false;
        self.nmi_output = false;
        self.even_frame = true;
        self.data_buffer = 0;
        self.suppress_vblank = false;
        
        // Clear OAM, VRAM, and palette RAM
        self.oam = [0; 256];
        self.secondary_oam = [0; 32];
        self.vram = [0; 2048];
        self.palette_ram = [0; 32];
        
        // Reset rendering state
        self.bg.reset();
        self.sprites.reset();
    }

    /// Run a single PPU cycle
    pub fn step(&mut self, bus: &mut MemoryBus) {
        // Clear frame buffer at the start of a new frame
        if self.scanline == 0 && self.cycle == 0 {
            self.frame_buffer.fill(0);
        }

        // Visible scanlines (0-239)
        if self.scanline <= LAST_VISIBLE_SCANLINE {
            // Visible cycles (0-255)
            if self.cycle <= VISIBLE_CYCLES_PER_SCANLINE {
                // Render current pixel
                let rendering_enabled = (bus.ppu_registers[1] & 0x18) != 0;
                
                if rendering_enabled {
                    // Background rendering
                    let bg_pixel = self.bg.get_pixel(self.v, self.x);
                    
                    // Sprite rendering
                    let sprite_pixel = self.sprites.get_pixel(self.cycle - 1, self.scanline);
                    
                    // Determine final pixel color
                    let (palette_index, _) = self.get_pixel_color(bg_pixel, sprite_pixel);
                    
                    // Convert palette index to RGB
                    let color = self.palette_table.borrow().get_color(self.palette_ram[palette_index as usize]);
                    
                    // Write to frame buffer
                    if self.cycle > 0 && self.scanline < SCREEN_HEIGHT as u16 {
                        let x = (self.cycle - 1) as u32;
                        let y = self.scanline as u32;
                        let index = ((y * SCREEN_WIDTH + x) * 3) as usize;
                        
                        self.frame_buffer[index] = color.0;     // R
                        self.frame_buffer[index + 1] = color.1; // G
                        self.frame_buffer[index + 2] = color.2; // B
                    }
                }
                
                // Fetch background tiles
                if rendering_enabled && self.cycle % 8 == 0 {
                    let v = self.v;
                    let cycle = self.cycle;
                    let rendering_enabled = (bus.ppu_registers[1] & 0x18) != 0;
                    self.bg.fetch_tile_data(v, cycle, rendering_enabled, bus);
                }
                
                // Increment horizontal position
                if rendering_enabled && self.cycle == 256 {
                    self.increment_x();
                }
            }
            
            // End of visible scanline
            if self.cycle == 257 {
                // Sprite evaluation for next scanline
                if (bus.ppu_registers[1] & 0x18) != 0 {
                    self.sprites.evaluate_sprites(self.scanline + 1, &self.oam);
                }
                
                // Reset horizontal position
                if (bus.ppu_registers[1] & 0x18) != 0 {
                    self.v = (self.v & 0x7BE0) | (self.t & 0x041F);
                }
            }
        }
        
        // Pre-render scanline (261)
        if self.scanline == PRE_RENDER_SCANLINE {
            // Clear VBlank, sprite 0 hit, and sprite overflow flags
            if self.cycle == 1 {
                bus.ppu_registers[2] &= 0x1F;
                self.nmi_occurred = false;
                self.sprites.sprite_zero_hit = false;
                self.sprites.sprite_overflow = false;
            }
            
            // Clear secondary OAM
            if self.cycle == 1 {
                self.secondary_oam = [0xFF; 32];
            }
            
            // Copy vertical scroll bits
            if self.cycle >= 280 && self.cycle <= 304 && (bus.ppu_registers[1] & 0x18) != 0 {
                self.v = (self.v & 0x041F) | (self.t & 0x7BE0);
            }
        }
        
        // VBlank scanline (241)
        if self.scanline == 241 && self.cycle == 1 {
            self.nmi_occurred = true;
            
            if self.nmi_output && !self.suppress_vblank {
                bus.ppu_registers[2] |= 0x80;
            }
        }
        
        // Increment cycle and scanline counters
        self.cycle += 1;
        if self.cycle > CYCLES_PER_SCANLINE {
            // Skip last cycle on odd frames (NTSC only)
            if self.tv_system == TVSystem::NTSC && !self.even_frame && self.scanline == 261 && (bus.ppu_registers[1] & 0x18) != 0 {
                self.cycle = 0;
                self.scanline = 0;
                self.even_frame = !self.even_frame;
                self.frame += 1;
            } else {
                self.cycle = 0;
                self.scanline += 1;
                
                if self.scanline >= self.scanlines_per_frame() {
                    self.scanline = 0;
                    self.even_frame = !self.even_frame;
                    self.frame += 1;
                }
            }
        }
    }

    /// Get scanlines per frame based on TV system
    fn scanlines_per_frame(&self) -> u16 {
        match self.tv_system {
            TVSystem::NTSC => 262,
            TVSystem::PAL | TVSystem::Dendy => 312,
        }
    }

    /// Get the current frame buffer
    pub fn get_frame_buffer(&self) -> &[u8] {
        &self.frame_buffer
    }

    /// Read a byte from PPU memory
    pub fn read(&self, addr: u16, bus: &MemoryBus) -> u8 {
        let addr = addr & 0x3FFF; // Mirror down
        
        match addr {
            // Pattern tables (0x0000-0x1FFF)
            0x0000..=0x1FFF => {
                if let Some(cart) = bus.get_cartridge() {
                    cart.borrow().read_chr(addr)
                } else {
                    0
                }
            },
            
            // Nametables (0x2000-0x2FFF)
            0x2000..=0x2FFF => {
                let vram_addr = self.mirror_vram_addr(addr, bus) as usize;
                self.vram[vram_addr]
            },
            
            // Palette RAM (0x3F00-0x3FFF)
            0x3F00..=0x3FFF => {
                let palette_addr = self.mirror_palette_addr(addr) as usize;
                self.palette_ram[palette_addr]
            },
            
            _ => 0
        }
    }

    /// Write a byte to PPU memory
    pub fn write(&mut self, addr: u16, value: u8, bus: &MemoryBus) {
        let addr = addr & 0x3FFF; // Mirror down
        
        match addr {
            // Pattern tables (0x0000-0x1FFF)
            0x0000..=0x1FFF => {
                if let Some(cart) = bus.get_cartridge() {
                    cart.borrow_mut().write_chr(addr, value);
                }
            },
            
            // Nametables (0x2000-0x2FFF)
            0x2000..=0x2FFF => {
                let vram_addr = self.mirror_vram_addr(addr, bus) as usize;
                self.vram[vram_addr] = value;
            },
            
            // Palette RAM (0x3F00-0x3FFF)
            0x3F00..=0x3FFF => {
                let palette_addr = self.mirror_palette_addr(addr) as usize;
                self.palette_ram[palette_addr] = value;
            },
            
            _ => {}
        }
    }

    /// Handle mirroring of VRAM addresses based on the cartridge's mirroring mode
    fn mirror_vram_addr(&self, addr: u16, bus: &MemoryBus) -> u16 {
        let addr = addr & 0x2FFF;
        let mirroring = if let Some(cart) = bus.get_cartridge() {
            cart.borrow().get_mirroring()
        } else {
            Mirroring::Horizontal
        };
        
        match mirroring {
            Mirroring::Horizontal => {
                // Nametable layout:
                // A A
                // B B
                let table = (addr >> 11) & 0x01;
                (table << 10) | (addr & 0x03FF)
            },
            Mirroring::Vertical => {
                // Nametable layout:
                // A B
                // A B
                let table = (addr >> 10) & 0x01;
                (table << 10) | (addr & 0x03FF)
            },
            Mirroring::SingleScreenLower => {
                // Single screen, lower bank
                addr & 0x03FF
            },
            Mirroring::SingleScreenUpper => {
                // Single screen, upper bank
                0x0400 | (addr & 0x03FF)
            },
            Mirroring::FourScreen => {
                // Four screen - no mirroring
                addr & 0x0FFF
            },
        }
    }

    /// Handle mirroring of palette addresses
    fn mirror_palette_addr(&self, addr: u16) -> u16 {
        let addr = addr & 0x3F1F;
        if addr & 0x0F == 0 {
            // $3F00, $3F10, $3F20, $3F30 are mirrors of each other
            addr & 0x000F
        } else if addr & 0x03 == 0 {
            // $3F04, $3F08, $3F0C, $3F14, $3F18, $3F1C are mirrors
            addr & 0x000F
        } else {
            addr & 0x001F
        }
    }

    /// Increment X scroll (horizontal position)
    fn increment_x(&mut self) {
        if (self.v & 0x001F) == 31 {
            // Coarse X = 0, toggle horizontal nametable
            self.v &= !0x001F;
            self.v ^= 0x0400;
        } else {
            // Increment coarse X
            self.v += 1;
        }
    }

    /// Increment Y scroll (vertical position)
    fn increment_y(&mut self) {
        // Fine Y
        let fine_y = (self.v >> 12) & 0x07;
        if fine_y == 7 {
            // Fine Y = 0, increment coarse Y
            self.v &= !0x7000;
            
            // Coarse Y
            let coarse_y = (self.v >> 5) & 0x1F;
            if coarse_y == 29 {
                // Coarse Y = 0, toggle vertical nametable
                self.v &= !0x03E0;
                self.v ^= 0x0800;
            } else if coarse_y == 31 {
                // Coarse Y = 0, no nametable toggle
                self.v &= !0x03E0;
            } else {
                // Increment coarse Y
                self.v += 0x0020;
            }
        } else {
            // Increment fine Y
            self.v += 0x1000;
        }
    }

    /// Determine the final pixel color by combining background and sprite pixels
    fn get_pixel_color(&mut self, bg_pixel: (u8, u8), sprite_pixel: (u8, u8, bool, bool)) -> (u8, bool) {
        let (bg_palette, bg_pixel_value) = bg_pixel;
        let (sprite_palette, sprite_pixel_value, sprite_priority, sprite_zero) = sprite_pixel;
        
        // Check if pixels are transparent
        let bg_transparent = bg_pixel_value == 0;
        let sprite_transparent = sprite_pixel_value == 0;
        
        // Handle sprite zero hit detection
        if !bg_transparent && !sprite_transparent && sprite_zero && self.cycle != 255 {
            self.sprites.sprite_zero_hit = true;
        }
        
        // Determine final pixel
        if bg_transparent && sprite_transparent {
            // Both transparent, show background color
            (0, false)
        } else if bg_transparent && !sprite_transparent {
            // Background transparent, show sprite
            (0x10 + (sprite_palette * 4 + sprite_pixel_value) as u8, false)
        } else if !bg_transparent && sprite_transparent {
            // Sprite transparent, show background
            (bg_palette * 4 + bg_pixel_value, false)
        } else {
            // Both non-transparent, use priority
            if sprite_priority {
                // Sprite behind background
                (bg_palette * 4 + bg_pixel_value, true)
            } else {
                // Sprite in front of background
                (0x10 + (sprite_palette * 4 + sprite_pixel_value) as u8, false)
            }
        }
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\ppu\palette.rs`:

```rs
//! Palette handling for the PPU
//!
//! This module handles the NES color palette and color conversion.

/// RGB color tuple (Red, Green, Blue)
pub type Color = (u8, u8, u8);

/// NES color palette table
pub struct PaletteTable {
    /// Color entries
    colors: [Color; 64],
}

impl PaletteTable {
    /// Create a new NTSC palette table
    pub fn new_ntsc() -> Self {
        // Standard NTSC palette
        #[rustfmt::skip]
        let colors = [
            (0x54, 0x54, 0x54), (0x00, 0x1E, 0x74), (0x08, 0x10, 0x90), (0x30, 0x00, 0x88),
            (0x44, 0x00, 0x64), (0x5C, 0x00, 0x30), (0x54, 0x04, 0x00), (0x3C, 0x18, 0x00),
            (0x20, 0x2A, 0x00), (0x08, 0x3A, 0x00), (0x00, 0x40, 0x00), (0x00, 0x3C, 0x00),
            (0x00, 0x32, 0x3C), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
            
            (0x98, 0x96, 0x98), (0x08, 0x4C, 0xC4), (0x30, 0x32, 0xEC), (0x5C, 0x1E, 0xE4),
            (0x88, 0x14, 0xB0), (0xA0, 0x14, 0x64), (0x98, 0x22, 0x20), (0x78, 0x3C, 0x00),
            (0x54, 0x5A, 0x00), (0x28, 0x72, 0x00), (0x08, 0x7C, 0x00), (0x00, 0x76, 0x28),
            (0x00, 0x66, 0x78), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
            
            (0xEC, 0xEE, 0xEC), (0x4C, 0x9A, 0xEC), (0x78, 0x7C, 0xEC), (0xB0, 0x62, 0xEC),
            (0xE4, 0x54, 0xEC), (0xEC, 0x58, 0xB4), (0xEC, 0x6A, 0x64), (0xD4, 0x88, 0x20),
            (0xA0, 0xAA, 0x00), (0x74, 0xC4, 0x00), (0x4C, 0xD0, 0x20), (0x38, 0xCC, 0x6C),
            (0x38, 0xB4, 0xCC), (0x3C, 0x3C, 0x3C), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
            
            (0xEC, 0xEE, 0xEC), (0xA8, 0xCC, 0xEC), (0xBC, 0xBC, 0xEC), (0xD4, 0xB2, 0xEC),
            (0xEC, 0xAE, 0xEC), (0xEC, 0xAE, 0xD4), (0xEC, 0xB4, 0xB0), (0xE4, 0xC4, 0x90),
            (0xCC, 0xD2, 0x78), (0xB4, 0xDE, 0x78), (0xA8, 0xE2, 0x90), (0x98, 0xE2, 0xB4),
            (0xA0, 0xD6, 0xE4), (0xA0, 0xA2, 0xA0), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
        ];
        
        PaletteTable { colors }
    }
    
    /// Create a new PAL palette table
    pub fn new_pal() -> Self {
        // PAL color palette (slightly different from NTSC)
        #[rustfmt::skip]
        let colors = [
            (0x54, 0x54, 0x54), (0x00, 0x1E, 0x74), (0x08, 0x10, 0x90), (0x30, 0x00, 0x88),
            (0x44, 0x00, 0x64), (0x5C, 0x00, 0x30), (0x54, 0x04, 0x00), (0x3C, 0x18, 0x00),
            (0x20, 0x2A, 0x00), (0x08, 0x3A, 0x00), (0x00, 0x40, 0x00), (0x00, 0x3C, 0x00),
            (0x00, 0x32, 0x3C), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
            
            (0x98, 0x96, 0x98), (0x08, 0x4C, 0xC4), (0x30, 0x32, 0xEC), (0x5C, 0x1E, 0xE4),
            (0x88, 0x14, 0xB0), (0xA0, 0x14, 0x64), (0x98, 0x22, 0x20), (0x78, 0x3C, 0x00),
            (0x54, 0x5A, 0x00), (0x28, 0x72, 0x00), (0x08, 0x7C, 0x00), (0x00, 0x76, 0x28),
            (0x00, 0x66, 0x78), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
            
            (0xEC, 0xEE, 0xEC), (0x4C, 0x9A, 0xEC), (0x78, 0x7C, 0xEC), (0xB0, 0x62, 0xEC),
            (0xE4, 0x54, 0xEC), (0xEC, 0x58, 0xB4), (0xEC, 0x6A, 0x64), (0xD4, 0x88, 0x20),
            (0xA0, 0xAA, 0x00), (0x74, 0xC4, 0x00), (0x4C, 0xD0, 0x20), (0x38, 0xCC, 0x6C),
            (0x38, 0xB4, 0xCC), (0x3C, 0x3C, 0x3C), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
            
            (0xEC, 0xEE, 0xEC), (0xA8, 0xCC, 0xEC), (0xBC, 0xBC, 0xEC), (0xD4, 0xB2, 0xEC),
            (0xEC, 0xAE, 0xEC), (0xEC, 0xAE, 0xD4), (0xEC, 0xB4, 0xB0), (0xE4, 0xC4, 0x90),
            (0xCC, 0xD2, 0x78), (0xB4, 0xDE, 0x78), (0xA8, 0xE2, 0x90), (0x98, 0xE2, 0xB4),
            (0xA0, 0xD6, 0xE4), (0xA0, 0xA2, 0xA0), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
        ];
        
        PaletteTable { colors }
    }
    
    /// Get a color for the given palette index
    pub fn get_color(&self, index: u8) -> Color {
        self.colors[(index & 0x3F) as usize]
    }
    
    /// Get a slice of all colors
    pub fn get_all_colors(&self) -> &[Color] {
        &self.colors
    }
    
    /// Set a specific color in the palette
    pub fn set_color(&mut self, index: usize, color: Color) {
        if index < self.colors.len() {
            self.colors[index] = color;
        }
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\ppu\sprites.rs`:

```rs
//! Sprite rendering for the PPU
//!
//! This module handles rendering the sprite tiles for the NES.
//! Sprites are 8x8 or 8x16 pixel objects that can be positioned anywhere on screen.

/// Maximum number of sprites per scanline
pub const MAX_SPRITES_PER_SCANLINE: usize = 8;

/// Sprite rendering state
#[derive(Clone)]
pub struct Sprites {
    /// Sprite zero is present on current scanline
    pub sprite_zero_present: bool,
    
    /// Sprite zero hit flag
    pub sprite_zero_hit: bool,
    
    /// Sprite overflow flag
    pub sprite_overflow: bool,
    
    /// Sprite scanline buffer
    scanline_sprites: [SpriteData; MAX_SPRITES_PER_SCANLINE],
    
    /// Number of sprites on current scanline
    sprite_count: usize,
}

/// Data for a single sprite
#[derive(Copy, Clone, Default)]
struct SpriteData {
    /// X position
    x: u8,
    
    /// Y position
    y: u8,
    
    /// Tile index
    tile: u8,
    
    /// Attribute byte
    attribute: u8,
    
    /// Pattern data for sprite (low byte)
    pattern_lo: u8,
    
    /// Pattern data for sprite (high byte)
    pattern_hi: u8,
}

impl SpriteData {
    /// Create a new sprite data
    fn new(x: u8, y: u8, tile: u8, attribute: u8) -> Self {
        SpriteData {
            x,
            y,
            tile,
            attribute,
            pattern_lo: 0,
            pattern_hi: 0,
        }
    }
}

impl Sprites {
    /// Create a new sprite rendering state
    pub fn new() -> Self {
        Sprites {
            sprite_zero_present: false,
            sprite_zero_hit: false,
            sprite_overflow: false,
            scanline_sprites: [SpriteData::default(); MAX_SPRITES_PER_SCANLINE],
            sprite_count: 0,
        }
    }
    
    /// Reset the sprite rendering state
    pub fn reset(&mut self) {
        self.sprite_zero_present = false;
        self.sprite_zero_hit = false;
        self.sprite_overflow = false;
        self.scanline_sprites = [SpriteData::default(); MAX_SPRITES_PER_SCANLINE];
        self.sprite_count = 0;
    }
    
    /// Evaluate sprites for the next scanline
    pub fn evaluate_sprites(&mut self, scanline: u16, oam: &[u8]) {
        // Clear sprite count
        self.sprite_count = 0;
        self.sprite_zero_present = false;
        
        // Check which sprites are visible on the next scanline
        for i in 0..64 {
            // Get sprite data
            let idx = i * 4;
            let y = oam[idx];
            let tile = oam[idx + 1];
            let attr = oam[idx + 2];
            let x = oam[idx + 3];
            
            // Check if sprite is visible on this scanline
            let in_range = scanline >= y as u16 && scanline < (y as u16 + 8);
            
            if in_range {
                // Add sprite to scanline buffer
                if self.sprite_count < MAX_SPRITES_PER_SCANLINE {
                    self.scanline_sprites[self.sprite_count] = SpriteData::new(x, y, tile, attr);
                    
                    // Check if this is sprite zero
                    if i == 0 {
                        self.sprite_zero_present = true;
                    }
                    
                    self.sprite_count += 1;
                } else {
                    // Sprite overflow
                    self.sprite_overflow = true;
                    break;
                }
            }
        }
    }
    
    /// Load pattern data for sprites
    pub fn load_sprite_patterns(&mut self, ppu_ctrl: u8, pattern_table: &[u8]) {
        // Pattern table selection for sprites
        let sprite_pattern_table_addr = if (ppu_ctrl & 0x08) != 0 { 0x1000 } else { 0x0000 };
        
        // Load pattern data for each sprite
        for i in 0..self.sprite_count {
            let sprite = &mut self.scanline_sprites[i];
            
            // Determine pattern address
            let mut pattern_addr = sprite_pattern_table_addr + (sprite.tile as u16 * 16);
            
            // Apply Y flipping if needed
            let row = if (sprite.attribute & 0x80) != 0 {
                7 - (sprite.y as u16 % 8)
            } else {
                sprite.y as u16 % 8
            };
            
            pattern_addr += row;
            
            // Load pattern data
            sprite.pattern_lo = pattern_table[pattern_addr as usize];
            sprite.pattern_hi = pattern_table[(pattern_addr + 8) as usize];
            
            // Apply X flipping if needed
            if (sprite.attribute & 0x40) != 0 {
                // Flip bits horizontally
                sprite.pattern_lo = Self::flip_byte(sprite.pattern_lo);
                sprite.pattern_hi = Self::flip_byte(sprite.pattern_hi);
            }
        }
    }
    
    /// Get the sprite pixel at the given position
    pub fn get_pixel(&self, x: u16, _y: u16) -> (u8, u8, bool, bool) {
        // Check each sprite in the secondary OAM
        for i in 0..8 {
            let sprite_x = self.scanline_sprites[i].x;
            let sprite_attr = self.scanline_sprites[i].attribute;
            let sprite_pattern_lo = self.scanline_sprites[i].pattern_lo;
            let sprite_pattern_hi = self.scanline_sprites[i].pattern_hi;
            
            // Check if sprite is visible at this x position
            if x >= sprite_x as u16 && x < (sprite_x as u16 + 8) {
                let mut pattern_bit = 7 - ((x - sprite_x as u16) as u8);
                
                // Handle horizontal flip
                if (sprite_attr & 0x40) != 0 {
                    pattern_bit = 7 - pattern_bit;
                }
                
                // Get pixel value
                let pixel_lo = ((sprite_pattern_lo >> pattern_bit) & 0x01) as u8;
                let pixel_hi = ((sprite_pattern_hi >> pattern_bit) & 0x01) << 1;
                let pixel_val = pixel_hi | pixel_lo;
                
                // If pixel is non-transparent
                if pixel_val != 0 {
                    let palette = (sprite_attr & 0x03) as u8;
                    let behind_bg = (sprite_attr & 0x20) != 0;
                    let sprite_zero = i == 0;
                    
                    return (palette, pixel_val, behind_bg, sprite_zero);
                }
            }
        }
        
        // No sprite pixel found
        (0, 0, false, false)
    }
    
    /// Flip a byte (reverse bit order)
    fn flip_byte(b: u8) -> u8 {
        let mut result = 0;
        for i in 0..8 {
            result |= ((b >> i) & 0x01) << (7 - i);
        }
        result
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\savestate.rs`:

```rs
//! Save state implementation
//!
//! This module handles saving and loading the emulator state, allowing users
//! to save their progress and restore it later. Save states capture the complete
//! state of the emulator, including CPU, PPU, APU, memory, and mapper state.
//! 
//! Save states are versioned to ensure compatibility across different versions
//! of the emulator. Files are serialized using bincode with Serde.

use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;
use std::borrow::BorrowMut;
use log::{info, warn};
use thiserror::Error;
use bincode::{Encode, Decode, BorrowDecode};
use bincode::{encode_into_std_write, decode_from_std_read};
use serde::{Serialize, Deserialize};

use crate::ppu::TVSystem;
use crate::nes::NES;
use crate::cartridge::Mirroring;

/// Current save state format version
const CURRENT_SAVE_STATE_VERSION: u32 = 1;

/// Errors that can occur during save state operations
#[derive(Error, Debug)]
pub enum SaveStateError {
    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Deserialization error: {0}")]
    DeserializationError(String),
    
    #[error("Incompatible save state version: found {0}, expected {1}")]
    IncompatibleVersion(u32, u32),
    
    #[error("Unsupported mapper type: {0}")]
    UnsupportedMapper(u8),
    
    #[error("Invalid save state data")]
    InvalidData,
    
    #[error("No cartridge loaded")]
    NoCartridge,
}

/// Save state data
#[derive(Serialize, Deserialize, Encode)]
pub struct SaveState {
    /// Save state format version
    version: u32,
    
    /// CPU state
    cpu: CpuState,
    
    /// PPU state
    ppu: PpuState,
    
    /// APU state
    apu: ApuState,
    
    /// Memory state
    memory: MemoryState,
    
    /// Cartridge state
    cartridge: CartridgeState,
}

/// CPU state data
#[derive(Serialize, Deserialize, Encode, Decode)]
struct CpuState {
    a: u8,
    x: u8,
    y: u8,
    sp: u8,
    pc: u16,
    p: u8,
    cycles: u8,
    total_cycles: u64,
    waiting: bool,
}

/// PPU state data
#[derive(Serialize, Deserialize, Encode, Decode)]
struct PpuState {
    cycle: u16,
    scanline: u16,
    frame: u64,
    v: u16,
    t: u16,
    x: u8,
    w: bool,
    nmi_occurred: bool,
    nmi_output: bool,
    even_frame: bool,
    data_buffer: u8,
    vram: Vec<u8>,
    palette_ram: Vec<u8>,
    oam: Vec<u8>,
    tv_system: TVSystem,
    sprite_zero_hit: bool,
    sprite_overflow: bool,
}

/// APU state data
#[derive(Serialize, Deserialize, Encode, Decode)]
struct ApuState {
    pulse1: PulseState,
    pulse2: PulseState,
    triangle: TriangleState,
    noise: NoiseState,
    dmc: DmcState,
    frame_counter: u8,
    frame_irq_inhibit: bool,
    frame_counter_mode: bool,
    frame_sequence: u8,
    cycles: u64,
}

/// Pulse channel state
#[derive(Serialize, Deserialize, Encode, Decode)]
struct PulseState {
    enabled: bool,
    duty: u8,
    length_counter_halt: bool,
    constant_volume: bool,
    volume: u8,
    sweep_enabled: bool,
    sweep_period: u8,
    sweep_negative: bool,
    sweep_shift: u8,
    timer_period: u16,
    length_counter: u8,
    timer: u16,
    sequencer_step: u8,
    envelope_start: bool,
    envelope_divider: u8,
    envelope_decay: u8,
    envelope_volume: u8,
    sweep_reload: bool,
    sweep_divider: u8,
    muted: bool,
}

/// Triangle channel state
#[derive(Serialize, Deserialize, Encode, Decode)]
struct TriangleState {
    enabled: bool,
    linear_counter_reload: bool,
    linear_counter_period: u8,
    length_counter_halt: bool,
    timer_period: u16,
    length_counter: u8,
    timer: u16,
    sequencer_step: u8,
    linear_counter: u8,
    linear_counter_reload_flag: bool,
}

/// Noise channel state
#[derive(Serialize, Deserialize, Encode, Decode)]
struct NoiseState {
    enabled: bool,
    length_counter_halt: bool,
    constant_volume: bool,
    volume: u8,
    mode: bool,
    timer_period: u16,
    length_counter: u8,
    timer: u16,
    shift_register: u16,
    envelope_start: bool,
    envelope_divider: u8,
    envelope_decay: u8,
    envelope_volume: u8,
}

/// DMC channel state
#[derive(Serialize, Deserialize, Encode, Decode)]
struct DmcState {
    enabled: bool,
    irq_enabled: bool,
    loop_flag: bool,
    timer_period: u16,
    output_level: u8,
    sample_address: u16,
    sample_length: u16,
    timer: u16,
    sample_buffer: u8,
    sample_buffer_empty: bool,
    current_address: u16,
    bytes_remaining: u16,
    shift_register: u8,
    bits_remaining: u8,
    silent: bool,
}

/// Memory state data
#[derive(Serialize, Deserialize, Encode, Decode)]
struct MemoryState {
    ram: Vec<u8>,
    ppu_registers: Vec<u8>,
    apu_io_registers: Vec<u8>,
    oam_dma_active: bool,
    oam_dma_addr: u8,
    oam_dma_page: u8,
    nmi_pending: bool,
    irq_pending: bool,
}

/// Cartridge state data
#[derive(Serialize, Deserialize, Encode, Decode)]
struct CartridgeState {
    /// Mapper number
    mapper_number: u8,
    
    /// PRG RAM content
    prg_ram: Vec<u8>,
    
    /// CHR RAM content (if present)
    chr_ram: Vec<u8>,
    
    /// Whether the cartridge has battery-backed RAM
    has_battery: bool,
    
    /// Mirroring mode
    mirroring: Mirroring,
    
    /// Mapper-specific state
    mapper_state: MapperState,
}

/// Mapper-specific state data
#[derive(Serialize, Deserialize, Encode, Decode)]
enum MapperState {
    /// NROM (Mapper 0) - No state needed
    Mapper000,
    
    /// MMC1 (Mapper 1)
    Mapper001(MMC1State),
    
    /// UxROM (Mapper 2)
    Mapper002(UxROMState),
    
    /// CNROM (Mapper 3)
    Mapper003(CNROMState),
    
    /// MMC3 (Mapper 4)
    Mapper004(MMC3State),
    
    /// Raw bytes for other/unknown mappers
    Unknown(Vec<u8>),
}

/// MMC1 (Mapper 1) state
#[derive(Serialize, Deserialize, Encode, Decode)]
struct MMC1State {
    shift_register: u8,
    shift_count: u8,
    control: u8,
    chr_bank_0: u8,
    chr_bank_1: u8,
    prg_bank: u8,
}

/// UxROM (Mapper 2) state
#[derive(Serialize, Deserialize, Encode, Decode)]
struct UxROMState {
    prg_bank: u8,
}

/// CNROM (Mapper 3) state
#[derive(Serialize, Deserialize, Encode, Decode)]
struct CNROMState {
    chr_bank: u8,
}

/// MMC3 (Mapper 4) state
#[derive(Serialize, Deserialize, Encode, Decode)]
struct MMC3State {
    bank_select: u8,
    bank_registers: [u8; 8],
    prg_mode: u8,
    chr_mode: u8,
    irq_counter: u8,
    irq_latch: u8,
    irq_enabled: bool,
    irq_pending: bool,
    irq_reload: bool,
    prg_ram_protect: [bool; 2],
}

/// Create a bincode configuration optimized for size
fn config() -> bincode::config::Configuration {
    bincode::config::standard()
}

/// Serialize data using bincode
fn serialize<T: Serialize + Encode>(value: &T, config: bincode::config::Configuration) -> Result<Vec<u8>, bincode::error::EncodeError> {
    let mut buffer = Vec::new();
    encode_into_std_write(value, &mut buffer, config)?;
    Ok(buffer)
}

/// Deserialize data using bincode
fn deserialize<T: for<'a> Deserialize<'a> + Decode<()>>(data: &[u8], config: bincode::config::Configuration) -> Result<T, bincode::error::DecodeError> {
    decode_from_std_read(&mut &*data, config)
}

// Implement Encode and Decode for TVSystem
impl Encode for TVSystem {
    fn encode<E: bincode::enc::Encoder>(&self, encoder: &mut E) -> Result<(), bincode::error::EncodeError> {
        match self {
            TVSystem::NTSC => 0u8.encode(encoder),
            TVSystem::PAL => 1u8.encode(encoder),
            TVSystem::Dendy => 2u8.encode(encoder),
        }
    }
}

impl Decode<()> for TVSystem {
    fn decode<D: bincode::de::Decoder>(decoder: &mut D) -> Result<Self, bincode::error::DecodeError> {
        let value = u8::decode(decoder)?;
        match value {
            0 => Ok(TVSystem::NTSC),
            1 => Ok(TVSystem::PAL),
            2 => Ok(TVSystem::Dendy),
            _ => Err(bincode::error::DecodeError::Other("Invalid TVSystem value")),
        }
    }
}

impl<'de> BorrowDecode<'de, ()> for TVSystem {
    fn borrow_decode<D: bincode::de::BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, bincode::error::DecodeError> {
        let value = u8::decode(decoder)?;
        match value {
            0 => Ok(TVSystem::NTSC),
            1 => Ok(TVSystem::PAL),
            2 => Ok(TVSystem::Dendy),
            _ => Err(bincode::error::DecodeError::Other("Invalid TVSystem value")),
        }
    }
}

// Implement Encode and Decode for Mirroring
impl Encode for Mirroring {
    fn encode<E: bincode::enc::Encoder>(&self, encoder: &mut E) -> Result<(), bincode::error::EncodeError> {
        match self {
            Mirroring::Horizontal => 0u8.encode(encoder),
            Mirroring::Vertical => 1u8.encode(encoder),
            Mirroring::FourScreen => 2u8.encode(encoder),
            Mirroring::SingleScreenLower => 3u8.encode(encoder),
            Mirroring::SingleScreenUpper => 4u8.encode(encoder),
        }
    }
}

impl Decode<()> for Mirroring {
    fn decode<D: bincode::de::Decoder>(decoder: &mut D) -> Result<Self, bincode::error::DecodeError> {
        let value = u8::decode(decoder)?;
        match value {
            0 => Ok(Mirroring::Horizontal),
            1 => Ok(Mirroring::Vertical),
            2 => Ok(Mirroring::FourScreen),
            3 => Ok(Mirroring::SingleScreenLower),
            4 => Ok(Mirroring::SingleScreenUpper),
            _ => Err(bincode::error::DecodeError::Other("Invalid Mirroring value")),
        }
    }
}

impl<'de> BorrowDecode<'de, ()> for Mirroring {
    fn borrow_decode<D: bincode::de::BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, bincode::error::DecodeError> {
        let value = u8::decode(decoder)?;
        match value {
            0 => Ok(Mirroring::Horizontal),
            1 => Ok(Mirroring::Vertical),
            2 => Ok(Mirroring::FourScreen),
            3 => Ok(Mirroring::SingleScreenLower),
            4 => Ok(Mirroring::SingleScreenUpper),
            _ => Err(bincode::error::DecodeError::Other("Invalid Mirroring value")),
        }
    }
}

impl SaveState {
    /// Create a new save state from the NES state
    pub fn from_nes(nes: &NES) -> Result<Self, SaveStateError> {
        // Extract CPU state
        let cpu_state = CpuState {
            a: nes.cpu.a,
            x: nes.cpu.x,
            y: nes.cpu.y,
            sp: nes.cpu.sp,
            pc: nes.cpu.pc,
            p: nes.cpu.p,
            cycles: nes.cpu.cycles,
            total_cycles: nes.cpu.total_cycles,
            waiting: nes.cpu.waiting,
        };
        
        // Extract PPU state
        let ppu_state = PpuState {
            cycle: nes.ppu.cycle,
            scanline: nes.ppu.scanline,
            frame: nes.ppu.frame,
            v: nes.ppu.v,
            t: nes.ppu.t,
            x: nes.ppu.x,
            w: nes.ppu.w,
            nmi_occurred: nes.ppu.nmi_occurred,
            nmi_output: nes.ppu.nmi_output,
            even_frame: nes.ppu.even_frame,
            data_buffer: nes.ppu.data_buffer,
            vram: nes.ppu.vram.to_vec(),
            palette_ram: nes.ppu.palette_ram.to_vec(),
            oam: nes.ppu.oam.to_vec(),
            tv_system: nes.ppu.tv_system,
            sprite_zero_hit: nes.ppu.sprites.sprite_zero_hit,
            sprite_overflow: nes.ppu.sprites.sprite_overflow,
        };
        
        // Extract memory state
        let memory_state = MemoryState {
            ram: nes.memory_bus.get_ram().to_vec(),
            ppu_registers: nes.memory_bus.ppu_registers.to_vec(),
            apu_io_registers: nes.memory_bus.apu_io_registers.to_vec(),
            oam_dma_active: nes.memory_bus.oam_dma_active,
            oam_dma_addr: nes.memory_bus.oam_dma_addr,
            oam_dma_page: nes.memory_bus.oam_dma_page,
            nmi_pending: nes.memory_bus.get_nmi_pending(),
            irq_pending: nes.memory_bus.get_irq_pending(),
        };
        
        // Extract APU state (simplified for brevity)
        let apu_state = ApuState {
            pulse1: PulseState::default(),
            pulse2: PulseState::default(),
            triangle: TriangleState::default(),
            noise: NoiseState::default(),
            dmc: DmcState::default(),
            frame_counter: 0,
            frame_irq_inhibit: false,
            frame_counter_mode: false,
            frame_sequence: 0,
            cycles: 0,
        };
        // Extract cartridge state
        let cartridge_state = if let Some(cart_ref) = nes.memory_bus.get_cartridge() {
            let cart = cart_ref.borrow();
            
            // Get mapper number and cartridge details
            let mapper_number = cart.mapper_number();
            let has_battery = false; // This would come from the cartridge
            let mirroring = cart.get_mirroring();
            
            // Get PRG RAM
            let prg_ram = cart.save_ram();
            
            // Get CHR RAM (if any)
            let chr_ram = Vec::new(); // This would be extracted from the cartridge if CHR is RAM
            
            // Create mapper-specific state
            let mapper_state = match mapper_number {
                0 => MapperState::Mapper000,
                1 => {
                    // The actual implementation would extract these from the mapper
                    let mmc1_state = MMC1State {
                        shift_register: 0x10, // Default value
                        shift_count: 0,
                        control: 0x0C,       // Initial control value
                        chr_bank_0: 0,
                        chr_bank_1: 0,
                        prg_bank: 0,
                    };
                    MapperState::Mapper001(mmc1_state)
                },
                2 => {
                    // Extract UxROM state
                    let uxrom_state = UxROMState {
                        prg_bank: 0, // This would come from the actual mapper
                    };
                    MapperState::Mapper002(uxrom_state)
                },
                3 => {
                    // Extract CNROM state
                    let cnrom_state = CNROMState {
                        chr_bank: 0, // This would come from the actual mapper
                    };
                    MapperState::Mapper003(cnrom_state)
                },
                4 => {
                    // Extract MMC3 state
                    let mmc3_state = MMC3State {
                        bank_select: 0,
                        bank_registers: [0; 8],
                        prg_mode: 0,
                        chr_mode: 0,
                        irq_counter: 0,
                        irq_latch: 0,
                        irq_enabled: false,
                        irq_pending: false,
                        irq_reload: false,
                        prg_ram_protect: [false, false],
                    };
                    MapperState::Mapper004(mmc3_state)
                },
                _ => {
                    // For other mappers, store raw bytes
                    MapperState::Unknown(Vec::new())
                }
            };
            
            CartridgeState {
                mapper_number,
                prg_ram,
                chr_ram,
                has_battery,
                mirroring,
                mapper_state,
            }
        } else {
            return Err(SaveStateError::NoCartridge);
        };
        
        Ok(SaveState {
            version: CURRENT_SAVE_STATE_VERSION,
            cpu: cpu_state,
            ppu: ppu_state,
            apu: apu_state,
            memory: memory_state,
            cartridge: cartridge_state,
        })
    }
    
    /// Apply save state to NES
    pub fn apply_to_nes(&self, nes: &mut NES) -> Result<(), SaveStateError> {
        // Check version compatibility
        if self.version != CURRENT_SAVE_STATE_VERSION {
            return Err(SaveStateError::IncompatibleVersion(
                self.version, 
                CURRENT_SAVE_STATE_VERSION
            ));
        }
        {
            // Make sure a cartridge is loaded
            let cartridge = nes.memory_bus.get_cartridge().ok_or(SaveStateError::NoCartridge)?;
            
            // Check that the mapper type matches
            let cart_ref = cartridge.borrow();
            if cart_ref.mapper_number() != self.cartridge.mapper_number {
                return Err(SaveStateError::UnsupportedMapper(self.cartridge.mapper_number));
            }
            drop(cart_ref);
        }
        
        // Apply CPU state
        nes.cpu.a = self.cpu.a;
        nes.cpu.x = self.cpu.x;
        nes.cpu.y = self.cpu.y;
        nes.cpu.sp = self.cpu.sp;
        nes.cpu.pc = self.cpu.pc;
        nes.cpu.p = self.cpu.p;
        nes.cpu.cycles = self.cpu.cycles;
        nes.cpu.total_cycles = self.cpu.total_cycles;
        nes.cpu.waiting = self.cpu.waiting;
        
        // Apply PPU state
        nes.ppu.cycle = self.ppu.cycle;
        nes.ppu.scanline = self.ppu.scanline;
        nes.ppu.frame = self.ppu.frame;
        nes.ppu.v = self.ppu.v;
        nes.ppu.t = self.ppu.t;
        nes.ppu.x = self.ppu.x;
        nes.ppu.w = self.ppu.w;
        nes.ppu.nmi_occurred = self.ppu.nmi_occurred;
        nes.ppu.nmi_output = self.ppu.nmi_output;
        nes.ppu.even_frame = self.ppu.even_frame;
        nes.ppu.data_buffer = self.ppu.data_buffer;
        nes.ppu.tv_system = self.ppu.tv_system;
        nes.ppu.sprites.sprite_zero_hit = self.ppu.sprite_zero_hit;
        nes.ppu.sprites.sprite_overflow = self.ppu.sprite_overflow;
        
        // Copy VRAM data
        if self.ppu.vram.len() == nes.ppu.vram.len() {
            nes.ppu.vram.copy_from_slice(&self.ppu.vram);
        } else {
            warn!("VRAM size mismatch: {} vs {}", self.ppu.vram.len(), nes.ppu.vram.len());
        }
        
        // Copy palette RAM data
        if self.ppu.palette_ram.len() == nes.ppu.palette_ram.len() {
            nes.ppu.palette_ram.copy_from_slice(&self.ppu.palette_ram);
        } else {
            warn!("Palette RAM size mismatch: {} vs {}", self.ppu.palette_ram.len(), nes.ppu.palette_ram.len());
        }
        
        // Copy OAM data
        if self.ppu.oam.len() == nes.ppu.oam.len() {
            nes.ppu.oam.copy_from_slice(&self.ppu.oam);
        } else {
            warn!("OAM size mismatch: {} vs {}", self.ppu.oam.len(), nes.ppu.oam.len());
        }
        {
            let mut memory_bus = nes.memory_bus.borrow_mut();
            // Apply memory state
            if self.memory.ram.len() == memory_bus.get_ram().len() {
                memory_bus.copy_ram(&self.memory.ram);
            } else {
                warn!("RAM size mismatch: {} vs {}", self.memory.ram.len(), memory_bus.get_ram().len());
            }
        }
        
        if self.memory.ppu_registers.len() == nes.memory_bus.ppu_registers.len() {
            nes.memory_bus.ppu_registers.copy_from_slice(&self.memory.ppu_registers);
        } else {
            warn!("PPU registers size mismatch: {} vs {}", 
                  self.memory.ppu_registers.len(), nes.memory_bus.ppu_registers.len());
        }
        
        if self.memory.apu_io_registers.len() == nes.memory_bus.apu_io_registers.len() {
            nes.memory_bus.apu_io_registers.copy_from_slice(&self.memory.apu_io_registers);
        } else {
            warn!("APU I/O registers size mismatch: {} vs {}", 
                  self.memory.apu_io_registers.len(), nes.memory_bus.apu_io_registers.len());
        }
        
        nes.memory_bus.oam_dma_active = self.memory.oam_dma_active;
        nes.memory_bus.oam_dma_addr = self.memory.oam_dma_addr;
        nes.memory_bus.oam_dma_page = self.memory.oam_dma_page;
        nes.memory_bus.set_nmi_pending(self.memory.nmi_pending);
        nes.memory_bus.set_irq_pending(self.memory.irq_pending);
        
        // Load cartridge state
        if let Some(cart) = nes.memory_bus.get_cartridge() {
            let cart_mut = &mut *cart.borrow_mut();
            
            // Load PRG RAM if any
            if !self.cartridge.prg_ram.is_empty() {
                cart_mut.load_ram(&self.cartridge.prg_ram);
            }
            
            // Load mapper-specific state
            match &self.cartridge.mapper_state {
                MapperState::Mapper000 => {
                    // NROM has no state to load
                },
                MapperState::Mapper001(mmc1_state) => {
                    // Apply MMC1 state
                    // In a real implementation, this would call into 
                    // a mapper-specific method to restore state
                    
                    // Example of what this might look like:
                    // cart_mut.write(0x8000, 0x80); // Reset
                    // cart_mut.write(0x8000, mmc1_state.control & 0x01);
                    // cart_mut.write(0x8000, mmc1_state.control >> 1 & 0x01);
                    // cart_mut.write(0x8000, mmc1_state.control >> 2 & 0x01);
                    // cart_mut.write(0x8000, mmc1_state.control >> 3 & 0x01);
                    // cart_mut.write(0x8000, mmc1_state.control >> 4 & 0x01);
                    // 
                    // // And so on for other registers
                },
                MapperState::Mapper002(uxrom_state) => {
                    // Apply UxROM state
                    // Example:
                    // cart_mut.write(0x8000, uxrom_state.prg_bank);
                },
                MapperState::Mapper003(cnrom_state) => {
                    // Apply CNROM state
                    // Example:
                    // cart_mut.write(0x8000, cnrom_state.chr_bank);
                },
                MapperState::Mapper004(mmc3_state) => {
                    // Apply MMC3 state
                    // This would be a sequence of writes to restore the state
                    // Example:
                    // cart_mut.write(0x8000, mmc3_state.bank_select);
                    // for i in 0..8 {
                    //     cart_mut.write(0x8001, mmc3_state.bank_registers[i]);
                    // }
                    // 
                    // // And so on for the rest of the state
                },
                MapperState::Unknown(_) => {
                    warn!("Unknown mapper state format, state not restored");
                },
            }
        }
        
        // At this point, the state has been fully restored
        info!("Save state restored successfully");
        Ok(())
    }
    
    /// Save state to a file
    pub fn save_to_file<P: AsRef<Path>>(nes: &NES, path: P) -> Result<(), SaveStateError> {
        // Create save state from NES
        let state = Self::from_nes(nes)?;
        
        // Serialize save state with configuration optimized for size
        let config = config();
        let data = serialize(&state, config)
            .map_err(|e| SaveStateError::SerializationError(e.to_string()))?;
        
        // Write to file
        let mut file = File::create(path.as_ref())
            .map_err(|e| SaveStateError::IoError(e))?;
        
        file.write_all(&data)
            .map_err(|e| SaveStateError::IoError(e))?;
        
        info!("Save state written to {}", path.as_ref().display());
        Ok(())
    }
    
    /// Load state from a file
    pub fn load_from_file<P: AsRef<Path>>(nes: &mut NES, path: P) -> Result<(), SaveStateError> {
        // Read file
        let mut file = File::open(path.as_ref())
            .map_err(|e| SaveStateError::IoError(e))?;
        
        let mut data = Vec::new();
        file.read_to_end(&mut data)
            .map_err(|e| SaveStateError::IoError(e))?;
        
        // Check for minimum file size
        if data.len() < 8 {
            return Err(SaveStateError::InvalidData);
        }
        
        // Deserialize save state
        let config = config();
        let state: SaveState = deserialize(&data, config)
            .map_err(|e| SaveStateError::DeserializationError(e.to_string()))?;
        
        // Apply save state to NES
        state.apply_to_nes(nes)?;
        
        info!("Save state loaded from {}", path.as_ref().display());
        Ok(())
    }
}

impl<'de> BorrowDecode<'de, ()> for SaveState {
    fn borrow_decode<D: bincode::de::BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, bincode::error::DecodeError> {
        Ok(SaveState {
            version: Decode::decode(decoder)?,
            cpu: Decode::decode(decoder)?,
            ppu: Decode::decode(decoder)?,
            apu: Decode::decode(decoder)?,
            memory: Decode::decode(decoder)?,
            cartridge: Decode::decode(decoder)?,
        })
    }
}

impl Decode<()> for SaveState {
    fn decode<D: bincode::de::Decoder>(decoder: &mut D) -> Result<Self, bincode::error::DecodeError> {
        Ok(SaveState {
            version: Decode::decode(decoder)?,
            cpu: Decode::decode(decoder)?,
            ppu: Decode::decode(decoder)?,
            apu: Decode::decode(decoder)?,
            memory: Decode::decode(decoder)?,
            cartridge: Decode::decode(decoder)?,
        })
    }
}

// Default implementations for APU channel states
impl Default for PulseState {
    fn default() -> Self {
        PulseState {
            enabled: false,
            duty: 0,
            length_counter_halt: false,
            constant_volume: false,
            volume: 0,
            sweep_enabled: false,
            sweep_period: 0,
            sweep_negative: false,
            sweep_shift: 0,
            timer_period: 0,
            length_counter: 0,
            timer: 0,
            sequencer_step: 0,
            envelope_start: false,
            envelope_divider: 0,
            envelope_decay: 0,
            envelope_volume: 0,
            sweep_reload: false,
            sweep_divider: 0,
            muted: false,
        }
    }
}

impl Default for TriangleState {
    fn default() -> Self {
        TriangleState {
            enabled: false,
            linear_counter_reload: false,
            linear_counter_period: 0,
            length_counter_halt: false,
            timer_period: 0,
            length_counter: 0,
            timer: 0,
            sequencer_step: 0,
            linear_counter: 0,
            linear_counter_reload_flag: false,
        }
    }
}

impl Default for NoiseState {
    fn default() -> Self {
        NoiseState {
            enabled: false,
            length_counter_halt: false,
            constant_volume: false,
            volume: 0,
            mode: false,
            timer_period: 0,
            length_counter: 0,
            timer: 0,
            shift_register: 1,
            envelope_start: false,
            envelope_divider: 0,
            envelope_decay: 0,
            envelope_volume: 0,
        }
    }
}

impl Default for DmcState {
    fn default() -> Self {
        DmcState {
            enabled: false,
            irq_enabled: false,
            loop_flag: false,
            timer_period: 0,
            output_level: 0,
            sample_address: 0,
            sample_length: 0,
            timer: 0,
            sample_buffer: 0,
            sample_buffer_empty: true,
            current_address: 0,
            bytes_remaining: 0,
            shift_register: 0,
            bits_remaining: 0,
            silent: true,
        }
    }
}
```

`\\?\C:\Users\parobek\GitHub\rustyNES\src\util.rs`:

```rs
//! Utility functions and helpers for the emulator
//!
//! This module contains various utility functions and helpers used throughout the
//! emulator code.

/// Combine two 8-bit values into a 16-bit value (little-endian)
#[inline]
pub fn combine_bytes(low: u8, high: u8) -> u16 {
    u16::from_le_bytes([low, high])
}

/// Split a 16-bit value into two 8-bit values (little-endian)
#[inline]
pub fn split_bytes(value: u16) -> (u8, u8) {
    let [low, high] = value.to_le_bytes();
    (low, high)
}

/// Determine if a page boundary is crossed when adding an offset to an address
#[inline]
pub fn page_boundary_crossed(addr: u16, offset: u8) -> bool {
    (addr & 0xFF00) != ((addr + offset as u16) & 0xFF00)
}

/// Get the stack pointer address
#[inline]
pub fn stack_address(sp: u8) -> u16 {
    0x0100 + sp as u16
}

/// Debug hexdump of a memory region
pub fn hexdump(data: &[u8], start_addr: u16) {
    for (i, chunk) in data.chunks(16).enumerate() {
        let addr = start_addr + (i * 16) as u16;
        print!("{:04X}: ", addr);
        
        for (j, byte) in chunk.iter().enumerate() {
            print!("{:02X} ", byte);
            if j == 7 {
                print!(" ");
            }
        }
        
        // Padding for incomplete lines
        for _ in chunk.len()..16 {
            print!("   ");
        }
        if chunk.len() <= 8 {
            print!(" ");
        }
        
        print!(" |");
        for byte in chunk {
            if *byte >= 0x20 && *byte < 0x7F {
                print!("{}", *byte as char);
            } else {
                print!(".");
            }
        }
        println!("|");
    }
}

/// Convert a byte to a binary string
pub fn byte_to_binary(byte: u8) -> String {
    format!("{:08b}", byte)
}

/// Format a 16-bit address as a hex string
pub fn format_addr(addr: u16) -> String {
    format!("${:04X}", addr)
}

/// Format an 8-bit value as a hex string
pub fn format_byte(value: u8) -> String {
    format!("${:02X}", value)
}

/// Calculate the number of CPU cycles for a given PPU scanline
pub fn cpu_cycles_per_scanline(tv_system: crate::ppu::TVSystem) -> u32 {
    match tv_system {
        crate::ppu::TVSystem::NTSC => 113, // 341 PPU cycles / 3 = ~113.67 CPU cycles
        crate::ppu::TVSystem::PAL | crate::ppu::TVSystem::Dendy => 106, // 319.5 PPU cycles / 3 = ~106.5 CPU cycles
    }
}

/// Check if a bit is set in a byte
#[inline]
pub fn check_bit(value: u8, bit: u8) -> bool {
    (value & (1 << bit)) != 0
}

/// Set a bit in a byte
#[inline]
pub fn set_bit(value: &mut u8, bit: u8) {
    *value |= 1 << bit;
}

/// Clear a bit in a byte
#[inline]
pub fn clear_bit(value: &mut u8, bit: u8) {
    *value &= !(1 << bit);
}
```